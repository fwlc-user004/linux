<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    تا اینجا با ابزارهایی مانند grep و awk برای جستجوی الگوهای متنی ساده کار
    کرده‌ایم. برای مثال، ما می‌توانیم تمام خطوطی که حاوی کلمه‌ی دقیق "error"
    هستند را پیدا کنیم. اما اگر بخواهیم الگوهای پیچیده‌تری را جستجو کنیم چه؟
    مثلاً «تمام خطوطی که با یک عدد شروع می‌شوند» یا «تمام خطوطی که حاوی یک آدرس
    ایمیل معتبر هستند».
  </p>
  <p>
    اینجاست که عبارات باقاعده (Regular Expressions) یا به اختصار Regex وارد عمل
    می‌شوند. Regex یک زبان کوچک و بسیار قدرتمند برای توصیف الگوهای متنی است. با
    یادگیری Regex، شما می‌توانید الگوهای جستجوی بسیار دقیق و پیچیده‌ای بسازید.
    تقریباً تمام ابزارهای پردازش متن در لینوکس (مانند grep، awk، sed و حتی
    ویرایشگرهایی مثل Vim) از Regex پشتیبانی می‌کنند و این مهارت، قدرت شما را در
    خط فرمان چندین برابر می‌کند.
  </p>
</section>
<section>
  <h2>فراداده ها: بلوک های سازنده ی Regex</h2>
  <p>
    جادوی Regex در استفاده از کاراکترهای خاصی به نام فراداده (Metacharacters)
    نهفته است. این کاراکترها به جای خودشان، مفهوم یا الگوی خاصی را نمایندگی
    میکنند. در ادامه با چند مورد از اصلی ترین فراداده ها آشنا میشویم.
  </p>
  <table>
    <thead>
      <tr>
        <th>فراداده</th>
        <th>توضیح</th>
        <th>مثال</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>.</td>
        <td>نقطه (Dot)</td>
        <td>با هر کاراکتر تکی مطابقت پیدا میکند (به جز کاراکتر خط جدید).</td>
      </tr>
      <tr>
        <td>^</td>
        <td>لنگر شروع (Start Anchor)</td>
        <td>موقعیت ابتدای خط را مشخص میکند.</td>
      </tr>
      <tr>
        <td>$</td>
        <td>لنگر پایان (End Anchor)</td>
        <td>موقعیت انتهای خط را مشخص میکند.</td>
      </tr>
      <tr>
        <td>*</td>
        <td>ستاره (Asterisk)</td>
        <td>
          با صفر یا چند بار تکرار کاراکتر یا گروه قبلی خود مطابقت پیدا میکند.
        </td>
      </tr>
      <tr>
        <td>[]</td>
        <td>کلاس کاراکتر (Character Class)</td>
        <td>
          با هر کاراکتر تکی که درون براکت ها مشخص شده باشد، مطابقت پیدا میکند.
          (مثلاً [abc] یا [0-9])
        </td>
      </tr>
      <tr>
        <td>\</td>
        <td>بک اسلش (Escape)</td>
        <td>
          معنی خاص یک فراداده را از بین میبرد و آن را به یک کاراکتر عادی تبدیل
          میکند. (مثلاً \. یعنی خود کاراکتر نقطه)
        </td>
      </tr>
    </tbody>
  </table>
</section>
<section>
  <h2>استفاده عملی از Regex با grep</h2>
  <p>
    بهترین راه برای یادگیری Regex، استفاده عملی از آن است. بیایید ببینیم چگونه
    میتوانیم این فراداده ها را با دستور grep به کار بگیریم.
  </p>
  <h3>مثال ۱: استفاده از لنگرها (^ و $)</h3>
  <p>
    لنگرها به ما اجازه میدهند الگو را به ابتدا یا انتهای خط مقید کنیم. دستور زیر
    تمام خطوطی از فایل /etc/passwd را پیدا میکند که دقیقاً با کلمه root شروع
    میشوند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep "^root" /etc/passwd
root:x:0:0:root:/root:/bin/bash</pre
  >
  <p>
    و دستور بعدی، کاربرانی را پیدا میکند که شل آن‌ها /bin/bash است، یعنی خط
    مربوط به آن‌ها به این عبارت ختم می‌شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep "/bin/bash$" /etc/passwd
root:x:0:0:root:/root:/bin/bash
me:x:1000:1000:me,,,:/home/me:/bin/bash</pre
  >
  <h3>مثال ۲: استفاده از کلاس کاراکتر ([])</h3>
  <p>
    کلاس کاراکتر برای مشخص کردن مجموعه ای از کاراکترهای مجاز استفاده می‌شود. فرض
    کنید میخواهیم خطوطی را پیدا کنیم که حاوی "gray" یا "grey" هستند. میتوانیم
    بنویسیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep "gr[ae]y" somefile.txt
</pre
  >
  <p>
    در این الگو، بخش [ae] به grep میگوید که در این موقعیت، کاراکتر a یا e قابل
    قبول است.
  </p>
  <h3>مثال ۳: استفاده از نقطه (.)</h3>
  <p>
    نقطه نماینده ی هر کاراکتر تکی است. الگوی 'c.t' با "cat"، "cot" و حتی "c_t"
    مطابقت پیدا میکند. استفاده از نقل قول دور الگوهایی که حاوی فراداده هستند،
    کار خوبی است تا از تفسیر آن‌ها توسط شل جلوگیری شود.
  </p>
</section>
<section>
  <h2>عبارات باقاعده پایه و توسعه یافته</h2>
  <p>
    دو «گویش» اصلی از Regex در خط فرمان لینوکس وجود دارد: عبارات باقاعده پایه
    (Basic Regular Expressions - BRE) و عبارات باقاعده توسعه یافته (Extended
    Regular Expressions - ERE).
  </p>
  <ul class="list-disc pr-6">
    <li>
      BRE: این گویش قدیمی تر است و به طور پیش فرض توسط grep استفاده میشود. در
      این حالت، برخی فراداده های قدرتمند مانند +، ? و | معنای خاصی ندارند مگر
      اینکه قبل از آن‌ها یک بک اسلش (\) قرار گیرد.
    </li>
    <li>
      ERE: این گویش مدرن تر و خواناتر است. در این حالت، فراداده های بیشتری به
      طور مستقیم کار میکنند.
    </li>
  </ul>
  <p>
    برای اینکه به grep بگوییم از گویش ERE استفاده کند، باید از گزینه ی -E
    استفاده کنیم (یا مستقیماً از دستور egrep که معمولاً معادل grep -E است).
  </p>
  <h3>فراداده های قدرتمند در ERE</h3>
  <p>گویش ERE چند فراداده بسیار مفید را در اختیار ما قرار میدهد:</p>
  <table>
    <thead>
      <tr>
        <th>فراداده</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>+</td>
        <td>با یک یا چند بار تکرار کاراکتر یا گروه قبلی مطابقت پیدا میکند.</td>
      </tr>
      <tr>
        <td>?</td>
        <td>
          با صفر یا یک بار تکرار کاراکتر یا گروه قبلی مطابقت پیدا میکند (یعنی آن
          را اختیاری میکند).
        </td>
      </tr>
      <tr>
        <td>|</td>
        <td>
          به عنوان عملگر "یا" (OR) عمل میکند. cat|dog با "cat" یا "dog" مطابقت
          دارد.
        </td>
      </tr>
      <tr>
        <td>()</td>
        <td>
          برای گروه بندی عبارات استفاده میشود تا بتوان روی کل گروه یک فراداده
          (مثل * یا +) اعمال کرد.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    برای مثال، برای پیدا کردن تمام خطوطی در یک فایل گزارش که حاوی کلمه ی "error"
    یا "warning" هستند، میتوانیم بنویسیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep -E "error|warning" system.log
</pre
  >
</section>
