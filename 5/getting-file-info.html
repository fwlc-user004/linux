<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    در فصل گذشته با مفاهیم قدرتمند Redirection و Piping آشنا شدیم و دیدیم که چگونه می‌توانیم جریان
    داده را بین دستورات و فایل‌ها هدایت کنیم. اکنون آماده‌ایم تا وارد مبحث جذاب «آنالیز و دستکاری
    فایل‌ها» شویم. در بسیاری از موارد، ما به کل محتوای یک فایل نیاز نداریم، بلکه به دنبال اطلاعات یا
    آمار خاصی از آن هستیم.
  </p>
  <p>
    این فصل را با یادگیری ابزارهایی شروع می‌کنیم که برای استخراج اطلاعات از فایل‌ها طراحی شده‌اند.
    ما یاد می‌گیریم چگونه آمار یک فایل متنی (تعداد خطوط، کلمات و کاراکترها) را به دست آوریم، چگونه
    در محتوای فایل‌ها به دنبال الگوهای خاصی بگردیم و چگونه به متادیتای کامل و جامعی از یک فایل
    دسترسی پیدا کنیم. ابزارهایی که در این درس با آن‌ها آشنا می‌شویم، یعنی <code>wc</code>، <code>grep</code> و
    <code>stat</code>، جزو پرکاربردترین دستورات هر مدیر سیستم یا توسعه‌دهنده‌ای هستند.
  </p>
</section>

<section>
  <h2>شمارش کلمات، خطوط و کاراکترها با wc</h2>
  <p>
    دستور <code>wc</code> (مخفف Word Count) یک ابزار ساده و در عین حال بسیار کاربردی برای
    شمارش است. این دستور می‌تواند تعداد خطوط، کلمات و بایت‌های یک فایل یا ورودی استاندارد را شمارش
    کند. اگر آن را به تنهایی روی یک فایل اجرا کنیم، سه عدد به ما می‌دهد:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ wc /etc/passwd
 47  95 2459 /etc/passwd
</pre>
  <p>
    خروجی بالا به ترتیب به این معناست: فایل <code>/etc/passwd</code> دارای ۴۷ خط، ۹۵ کلمه و ۲۴۵۹ بایت
    (کاراکتر) است.
  </p>

  <h3>گزینه‌های پرکاربرد wc</h3>
  <p>
    معمولاً ما فقط به یکی از این آمارها نیاز داریم. <code>wc</code> گزینه‌هایی دارد که به ما اجازه
    می‌دهد فقط اطلاعات مورد نظر خود را استخراج کنیم.
  </p>

  <table>
    <thead>
      <tr>
        <th>آپشن</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>-l</code></td>
        <td>فقط تعداد خطوط (lines) را می‌شمارد.</td>
      </tr>
      <tr>
        <td><code>-w</code></td>
        <td>فقط تعداد کلمات (words) را می‌شمارد.</td>
      </tr>
      <tr>
        <td><code>-c</code></td>
        <td>فقط تعداد بایت‌ها (characters/bytes) را می‌شمارد.</td>
      </tr>
    </tbody>
  </table>

  <p>
    قدرت واقعی <code>wc</code> زمانی مشخص می‌شود که در یک زنجیره‌ی پایپ به عنوان فیلتر استفاده شود.
    برای مثال، برای شمارش تعداد کاربران سیستم:
  </p>
<pre dir="ltr" data-cm-lang="bash">
$ cat /etc/passwd | wc -l
47
</pre>
</section>

<section>
  <h2>جستجو در محتوای فایل‌ها با grep</h2>
  <p>
    دستور <code>grep</code> (مخفف Global Regular Expression Print) بدون شک یکی
    از مهم‌ترین و پراستفاده‌ترین ابزارهای خط فرمان لینوکس است. وظیفه‌ی اصلی <code>grep</code> جستجوی
    یک الگوی متنی (pattern) در ورودی و چاپ کردن تمام خطوطی است که حاوی آن الگو هستند. این ابزار برای
    پیدا کردن اطلاعات خاص در فایل‌های حجیم مانند فایل‌های گزارش (Log) یا فایل‌های پیکربندی، حیاتی
    است.
  </p>
  <p>
    ساختار اصلی آن به شکل <code>grep "pattern" filename</code> است. برای مثال، برای پیدا کردن خط مربوط
    به کاربر <code>root</code> در فایل <code>/etc/passwd</code>:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep "root" /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:37:37:Operator,,,:/root:/bin/sh
  </pre>

  <h3>گزینه‌های مفید grep</h3>
  <p>
    دستور <code>grep</code> گزینه‌های بسیار زیادی برای کنترل جستجو دارد که در اینجا به چند مورد از
    مهم‌ترین آن‌ها اشاره می‌کنیم.
  </p>

  <table>
    <thead>
      <tr>
        <th>آپشن</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>-i</code></td>
        <td>جستجوی غیر حساس به بزرگی و کوچکی حروف (case-insensitive).</td>
      </tr>
      <tr>
        <td><code>-v</code></td>
        <td>جستجوی معکوس (invert). تمام خطوطی را چاپ می‌کند که با الگو مطابقت ندارند.</td>
      </tr>
      <tr>
        <td><code>-c</code></td>
        <td>فقط تعداد خطوطی که مطابقت دارند را می‌شمارد (count).</td>
      </tr>
      <tr>
        <td><code>-n</code></td>
        <td>شماره خط (number) را در ابتدای هر خط خروجی نمایش می‌دهد.</td>
      </tr>
      <tr>
        <td><code>-r</code> یا <code>-R</code></td>
        <td>به صورت بازگشتی (recursive) در تمام فایل‌های یک دایرکتوری و زیرشاخه‌های آن جستجو
          می‌کند.</td>
      </tr>
    </tbody>
  </table>

  <p>
    یک کاربرد بسیار رایج <code>grep -v</code>، فیلتر کردن خطوط کامنت (که با <code>#</code> شروع می‌شوند)
    از فایل‌های پیکربندی است تا فقط تنظیمات فعال نمایش داده شوند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ grep -v "#" /etc/some_config.conf
  </pre>
</section>

<section>
  <h2>بررسی متادیتای کامل فایل با stat</h2>
  <p>
    دستور <code>ls -l</code> اطلاعات مفیدی در مورد فایل‌ها به ما می‌دهد، اما گاهی به جزئیات بسیار
    بیشتری نیاز داریم. دستور <code>stat</code> (مخفف status) متادیتای کاملی که سیستم فایل در مورد
    یک فایل یا دایرکتوری ذخیره کرده است را به ما نشان می‌دهد.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ stat .bashrc
  File: .bashrc
  Size: 3771            Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 1192791     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/      me)   Gid: ( 1000/      me)
Access: 2025-07-20 10:30:00.000000000 -0400
Modify: 2025-07-15 11:25:00.000000000 -0400
Change: 2025-07-15 11:25:01.000000000 -0400
 Birth: -</pre>
  <p>این خروجی اطلاعات بسیار ارزشمندی را در بر دارد:</p>
  <ul class="list-disc pr-6">
    <li><b>Size و Blocks:</b> سایز واقعی فایل و مقدار فضایی که روی دیسک اشغال کرده است.</li>
    <li><b>Inode:</b> شماره شناسایی منحصربه‌فرد فایل در سیستم فایل.</li>
    <li><b>Links:</b> تعداد هاردلینک‌های اشاره‌کننده به این فایل.</li>
    <li><b>Access/Uid/Gid:</b> اطلاعات کامل دسترسی‌ها، شناسه‌ی کاربر و گروه مالک.</li>
    <li><b>Access/Modify/Change:</b> سه برچسب زمانی مهم. <b>Access</b> آخرین باری که فایل خوانده
      شده، <b>Modify</b> آخرین باری که محتوای فایل تغییر کرده و <b>Change</b> آخرین باری که
      متادیتای فایل (مثل دسترسی‌ها) تغییر کرده است را نشان می‌دهد.</li>
  </ul>
</section>

