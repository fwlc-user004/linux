<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    برای درک مفهوم پراسس، یک تشبیه ساده را در نظر بگیرید. یک برنامه روی دیسک (مثلاً فایل
    /bin/ls) مانند یک دستور آشپزی در یک کتاب است. این دستورالعمل‌ها به خودی خود غیرفعال
    هستند و کاری انجام نمی‌دهند. یک پراسس (Process) یا فرآیند، زمانی ایجاد می‌شود که کامپیوتر
    در حال اجرای آن دستور آشپزی است. به عبارت دیگر، پراسس، یک برنامه در حال اجراست.
  </p>
  <p>
    هر کاری که در سیستم لینوکس خود انجام می‌دهید، از اجرای یک دستور ساده در ترمینال گرفته تا باز
    کردن یک مرورگر وب یا اجرای سرویس‌های پس‌زمینه توسط سیستم، یک یا چند پراسس ایجاد می‌کند. مدیریت
    این پراسس‌ها - یعنی مشاهده‌ی آن‌ها، متوقف کردنشان در صورت نیاز و تغییر اولویتشان - یکی از
    مهارت‌های اصلی برای عیب‌یابی و مدیریت سیستم لینوکس است.
  </p>
</section>
<section>
  <h2>مشاهده‌ی پراسس‌ها با دستور <bdi>ps</bdi></h2>
  <p>
    ابزار اصلی برای مشاهده‌ی وضعیت پراسس‌های در حال اجرا، دستور <bdi>ps</bdi> (مخفف Process
    Status) است. اگر این دستور را بدون هیچ گزینه‌ای اجرا کنید، معمولاً فقط پراسس‌های مربوط به
    ترمینال فعلی خودتان را نمایش می‌دهد که چندان مفید نیست. برای دیدن تمام پراسس‌های در حال اجرا در
    سیستم، از ترکیب‌های خاصی از گزینه‌ها استفاده می‌کنیم. دو سبک رایج برای این کار وجود دارد:
  </p>
  <ul class="list-disc pr-6">
    <li>
      <b>سبک BSD (بدون خط تیره):</b> مانند <bdi>ps</bdi> aux. این سبک محبوب‌ترین و جامع‌ترین روش
      است.
    </li>
    <li>
      <b>سبک UNIX (با خط تیره):</b> مانند <bdi>ps</bdi> -ef. این سبک اطلاعات را کمی متفاوت نمایش
      می‌دهد و برای دیدن رابطه‌ی والد-فرزندی بین پراسس‌ها مفید است.
    </li>
  </ul>

  <h3>سبک BSD: دستور <bdi>ps</bdi> aux</h3>
  <p>
    این دستور یک لیست جامع از تمام پراسس‌های در حال اجرا را نمایش می‌دهد. ستون‌های مهم خروجی آن به
    شرح زیر است:
  </p>

  <table>
    <thead>
      <tr>
        <th>ستون</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>USER</td>
        <td>کاربری که پراسس را اجرا کرده است.</td>
      </tr>
      <tr>
        <td>PID</td>
        <td>Process ID. یک شماره‌ی شناسایی منحصربه‌فرد برای هر پراسس. این مهم‌ترین
          شناسه برای مدیریت یک پراسس است.</td>
      </tr>
      <tr>
        <td>%CPU</td>
        <td>درصد استفاده از پردازنده (CPU).</td>
      </tr>
      <tr>
        <td>%MEM</td>
        <td>درصد استفاده از حافظه (RAM).</td>
      </tr>
      <tr>
        <td>STAT</td>
        <td>وضعیت (Status) پراسس. مانند R (در حال اجرا)، S (در حال خواب
          - منتظر رویداد) یا Z (زامبی).</td>
      </tr>
      <tr>
        <td>COMMAND</td>
        <td>دستور یا برنامه‌ای که این پراسس را آغاز کرده است.</td>
      </tr>
    </tbody>
  </table>

  <h3>سبک UNIX: دستور <bdi>ps</bdi> -ef</h3>
  <p>
    این سبک نیز تمام پراسس‌ها را لیست می‌کند اما یک ستون بسیار مهم به نام PPID دارد.
  </p>
  <table>
    <thead>
      <tr>
        <th>ستون</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>UID</td>
        <td>شناسه‌ی کاربری (User ID) مالک پراسس.</td>
      </tr>
      <tr>
        <td>PID</td>
        <td>شناسه‌ی پراسس (Process ID).</td>
      </tr>
      <tr>
        <td>PPID</td>
        <td>Parent Process ID. شناسه‌ی پراسسِ والدی که این پراسس را ایجاد کرده
          است. این ستون به ما کمک می‌کند تا سلسله مراتب پراسس‌ها را ببینیم.</td>
      </tr>
      <tr>
        <td>CMD</td>
        <td>دستوری که پراسس را آغاز کرده است.</td>
      </tr>
    </tbody>
  </table>
  <p>
    در لینوکس، تمام پراسس‌ها یک ساختار درختی دارند. جد بزرگ تمام پراسس‌ها، پراسسی با PID=1
    است که معمولاً systemd یا init نام دارد و اولین پراسسی است که هنگام بوت
    شدن سیستم اجرا می‌شود.
  </p>
</section>
<section>
  <h2>خاتمه دادن به یک پراسس با دستور <bdi>kill</bdi></h2>
  <p>
    گاهی اوقات یک برنامه هنگ می‌کند یا به دلایلی لازم است یک پراسس را به صورت دستی متوقف کنیم. دستور
    <bdi>kill</bdi> برای این کار طراحی شده است. برخلاف نامش، کار اصلی این دستور «ارسال سیگنال» به یک
    پراسس است. ما با استفاده از PID، پراسس مورد نظر را مشخص کرده و به آن سیگنال
    می‌فرستیم.
  </p>
  <p>
    سیگنال پیش‌فرض، SIGTERM (با شماره ۱۵) است که یک درخواست «مؤدبانه» برای خاتمه دادن به
    پراسس است. این سیگنال به برنامه فرصت می‌دهد تا کارهای خود را تمام کرده، فایل‌هایش را ذخیره کند و
    به صورت تمیز خارج شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ps aux | grep firefox
me        12345  4.5  8.1 345678 123456 ?      Sl   10:30   2:05 firefox
$ kill 12345
</pre>

  <h3>حذف اجباری: سیگنال SIGKILL</h3>
  <p>
    گاهی یک پراسس به قدری دچار مشکل شده که به سیگنال مؤدبانه‌ی SIGTERM پاسخ نمی‌دهد. در
    این موارد، ما به سراغ سیگنال SIGKILL (با شماره ۹) می‌رویم. این سیگنال یک دستور
    خاتمه‌ی «اجباری» و بدون قید و شرط است که پراسس نمی‌تواند آن را نادیده بگیرد.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ kill -9 12345
$ kill -SIGKILL 12345
</pre>

  <div data-callout="warning">
    <strong>⚠️ احتیاط در استفاده از <bdi>kill</bdi> -9</strong>
    <p>
      استفاده از SIGKILL باید همیشه به عنوان آخرین راه حل در نظر گرفته شود. این سیگنال
      به برنامه هیچ فرصتی برای پاک‌سازی نمی‌دهد و می‌تواند منجر به از دست رفتن داده‌ها یا باقی
      ماندن فایل‌های موقت روی سیستم شود. همیشه ابتدا با یک <bdi>kill</bdi> عادی امتحان کنید و فقط
      در صورت عدم پاسخ، از <bdi>kill</bdi> -9 استفاده نمایید.
    </p>
  </div>

  <p>
    علاوه بر <bdi>kill</bdi>، ابزارهای راحت‌تری مانند <bdi>pkill</bdi> و <bdi>killall</bdi> نیز وجود
    دارند که به شما اجازه می‌دهند پراسس‌ها را بر اساس نامشان خاتمه دهید، نه PID. برای
    مثال: <bdi>pkill</bdi> firefox.
  </p>
</section>

