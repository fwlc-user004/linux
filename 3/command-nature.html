<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    تا اینجا با مجموعه‌ای از دستورات یا «کامندهای» پرکاربرد مثل ls، cd، cp، mv و
    rm آشنا شده‌ایم. ما این دستورات را در ترمینال تایپ کرده و با فشردن کلید
    Enter آن‌ها را اجرا می‌کنیم. اما آیا تا به حال از خود پرسیده‌اید که این
    کامندها واقعاً چه هستند؟ وقتی ما ls را تایپ می‌کنیم، دقیقاً چه اتفاقی در
    سیستم عامل رخ می‌دهد؟
  </p>
  <p>
    در نگاه اول شاید همه کامندها یکسان به نظر برسند، اما در حقیقت اینطور نیست.
    یک کامند در لینوکس می‌تواند یکی از چهار ماهیت زیر را داشته باشد:
  </p>
  <ul class="list-disc pr-6">
    <li>
      یک <b>برنامه اجرایی (Executable Program)</b> که به صورت یک فایل روی دیسک
      ذخیره شده است.
    </li>
    <li>
      یک <b>کامند داخلی شل (Shell Built-in)</b> که بخشی از خود برنامه شل (مثلاً
      bash) است.
    </li>
    <li>
      یک <b>تابع شل (Shell Function)</b> که مجموعه‌ای از دستورات تعریف شده توسط
      کاربر است.
    </li>
    <li>
      یک <b>نام مستعار (Alias)</b> که یک نام جایگزین برای یک دستور دیگر است.
    </li>
  </ul>
  <p>
    درک این تفاوت‌ها برای استفاده حرفه‌ای از خط فرمان ضروری است. در این درس، یاد
    می‌گیریم چگونه نوع هر کامند را تشخیص دهیم و با ویژگی‌های هر کدام از این چهار
    دسته آشنا می‌شویم.
  </p>
</section>
<section>
  <h2>تشخیص نوع یک کامند با دستور type</h2>
  <p>
    ساده‌ترین راه برای فهمیدن ماهیت یک کامند، استفاده از دستور داخلی
    type است. این دستور به ما می‌گوید که شل با نامی که وارد کرده‌ایم
    چگونه رفتار خواهد کرد. بیایید چند دستور که قبلاً یاد گرفته‌ایم را با
    type امتحان کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ type ls
ls is aliased to 'ls --color=auto'
$ type cp
cp is /usr/bin/cp
$ type cd
cd is a shell builtin
$ type type
type is a shell builtin</pre
  >
  <p>
    همان‌طور که خروجی‌ها نشان می‌دهند، هر کدام از این دستورات ماهیت متفاوتی
    دارند. ls یک نام مستعار (alias) است، cp یک فایل اجرایی در مسیر
    /usr/bin/cp است، و cd به همراه خودِ type جزو دستورات داخلی شل
    هستند. در ادامه هر یک از این موارد را با جزئیات بیشتری بررسی می‌کنیم.
  </p>
</section>
<section>
  <h2>بررسی دقیق انواع کامندها</h2>
  <p>
    اکنون که ابزار تشخیص نوع کامند را در اختیار داریم، بیایید عمیق‌تر به هر یک
    از این چهار دسته نگاه کنیم.
  </p>

  <h3>۱. برنامه‌های اجرایی (Executable Programs)</h3>
  <p>
    بسیاری از دستوراتی که ما استفاده می‌کنیم، در واقع برنامه‌های کوچکی هستند که
    به صورت فایل روی دیسک ذخیره شده‌اند. این فایل‌ها دارای یک پرچم دسترسی خاص به
    نام «مجوز اجرا» (executable permission) هستند که به سیستم عامل اجازه می‌دهد
    آن‌ها را به عنوان یک برنامه اجرا کند. این برنامه‌ها می‌توانند با زبان‌های
    مختلفی مانند C، پایتون یا حتی به صورت اسکریپت شل نوشته شده باشند.
  </p>
  <p>
    اما وقتی ما نام یک برنامه مثل cp را تایپ می‌کنیم، شل چگونه آن را پیدا
    می‌کند؟ شل به متغیری به نام $PATH نگاه می‌کند. این متغیر لیستی از
    مسیر دایرکتوری‌ها (که با علامت : از هم جدا شده‌اند) را در خود نگه
    می‌دارد. شل این دایرکتوری‌ها را به ترتیب جستجو می‌کند تا اولین فایلی که
    همنام با دستور وارد شده و قابل اجرا باشد را پیدا کند. با دستور echo
    می‌توانیم محتوای این متغیر را ببینیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</pre
  >
  <p>
    خروجی دستور type cp به ما نشان داد که این برنامه در مسیر
    /usr/bin/cp قرار دارد که یکی از مسیرهای موجود در متغیر
    $PATH است.
  </p>

  <h3>۲. کامندهای داخلی شل (Shell Built-ins)</h3>
  <p>
    این دسته از دستورات، فایل‌های جداگانه‌ای روی دیسک نیستند، بلکه جزئی از خود
    برنامه شل (مثلاً
    bash) هستند. وقتی شما یک دستور داخلی را اجرا می‌کنید، شل نیازی به
    جستجو در $PATH ندارد و آن را مستقیماً اجرا می‌کند. به همین دلیل،
    دستورات داخلی معمولاً سریع‌تر از برنامه‌های اجرایی خارجی عمل می‌کنند.
  </p>
  <p>
    مهم‌تر از سرعت، دلیل وجودی برخی از این دستورات است. برای مثال، دستور cd را
    در نظر بگیرید. وظیفه این دستور تغییر دایرکتوری کاریِ جاریِ شل است. اگر cd یک
    برنامه خارجی بود، سیستم عامل یک پروسه جدید برای آن ایجاد می‌کرد. این پروسه
    جدید دایرکتوری کاری خودش را تغییر می‌داد و سپس کارش تمام می‌شد و از بین
    می‌رفت، در حالی که دایرکتوری کاری پروسه اصلی (شل ما) هیچ تغییری نمی‌کرد!
    بنابراین، دستوراتی که باید وضعیت خودِ شل را تغییر دهند، الزاماً باید به صورت
    داخلی (built-in) پیاده‌سازی شوند. دستورات pwd، exit،
    export و alias نمونه‌های دیگری از این دسته هستند.
  </p>

  <h3>۳. نام‌های مستعار (Aliases)</h3>
  <p>
    یک نام مستعار یا alias، یک نام جایگزین یا یک میان‌بُر برای یک دستور دیگر
    است. این ابزار برای کوتاه کردن دستورات طولانی یا اضافه کردن خودکار گزینه‌های
    دلخواه به یک دستور بسیار مفید است. همانطور که دیدیم، در بسیاری از توزیع‌های
    مدرن لینوکس، ls یک نام مستعار برای
    'ls --color=auto' است تا خروجی به صورت پیش‌فرض رنگی باشد.
  </p>
  <p>
    با اجرای دستور alias به تنهایی، می‌توانید لیست تمام نام‌های
    مستعار تعریف شده در سیستم خود را ببینید. برای ساختن یک alias جدید نیز از
    ساختار alias name='command' استفاده می‌کنیم. برای مثال:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ alias ll='ls -alh'
</pre
  >
  <p>
    با تعریف این alias، از این پس هر بار که در ترمینال ll را تایپ
    کنیم، در واقع دستور ls -alh اجرا خواهد شد. توجه داشته باشید که
    این aliasها موقتی هستند و فقط تا زمانی که نشست (session) فعلی ترمینال باز
    است، فعال می‌مانند. برای دائمی کردن آن‌ها باید تعریفشان را در فایل‌های
    پیکربندی شل مانند ~/.bashrc اضافه کنیم.
  </p>

  <h3>۴. توابع شل (Shell Functions)</h3>
  <p>
    توابع شل، پیچیده‌ترین نوع کامندها هستند. آن‌ها نسخه‌ی پیشرفته‌تری از aliasها
    به شمار می‌روند و به شما اجازه می‌دهند تا چندین دستور را تحت یک نام واحد
    گروه‌بندی کنید و منطق پیچیده‌تری را پیاده‌سازی نمایید. توابع نیز مانند
    کامندهای داخلی، مستقیماً توسط شل اجرا می‌شوند و در فایل‌های پیکربندی مانند
    ~/.bashrc تعریف می‌شوند. در فصل‌های آینده و در مبحث اسکریپت‌نویسی
    بیشتر با آن‌ها آشنا خواهیم شد.
  </p>
</section>
