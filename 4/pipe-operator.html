<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    در درس قبل با Redirection آشنا شدیم و دیدیم که چگونه می‌توانیم خروجی یک
    دستور را به یک فایل بفرستیم. این قابلیت بسیار مفید است، اما اگر نخواهیم
    خروجی را در یک فایل ذخیره کنیم، بلکه بخواهیم از آن به عنوان
    <b>ورودی برای یک دستور دیگر</b> استفاده کنیم چه؟ آیا باید ابتدا خروجی را در
    یک فایل موقت ذخیره کرده، سپس دستور دوم را با آن فایل اجرا کنیم و در نهایت
    فایل موقت را حذف کنیم؟ این روش بسیار ناکارآمد است.
  </p>
  <p>
    اینجا جایی است که عملگر <b>Pipe</b> یا «پایپ» با نماد <code>|</code> وارد میدان
    می‌شود. پایپ یکی از قدرتمندترین و بنیادی‌ترین مفاهیم در فلسفه
    یونیکس و لینوکس است. این عملگر به ما اجازه می‌دهد تا خروجی استاندارد
    (stdout) یک دستور را مستقیماً به ورودی استاندارد (stdin) یک دستور دیگر متصل
    کنیم. با استفاده از پایپ، می‌توانیم زنجیره‌ای از دستورات ساده
    بسازیم که با همکاری یکدیگر، وظایف بسیار پیچیده‌ای را انجام
    می‌دهند.
  </p>
</section>
<section>
  <h2>عملگر Pipe چگونه کار می‌کند؟</h2>
  <p>
    نحوه‌ی کار پایپ بسیار ساده و هوشمندانه است. ساختار کلی آن به شکل
    <code>command1 | command2</code>
    است. اتفاقی که می‌افتد به این صورت است:
  </p>
  <ol data-steps>
    <li>
      شل هر دو دستور <code>command1</code> و <code>command2</code> را تقریباً همزمان اجرا
      می‌کند.
    </li>
    <li>
      اما به جای اینکه خروجی استاندارد <code>command1</code> به صفحه نمایش برود، شل آن
      را به ورودی استاندارد <code>command2</code> متصل می‌کند.
    </li>
  </ol>
  <p>
    این فرآیند در حافظه‌ی سیستم (RAM) اتفاق می‌افتد و هیچ فایل موقتی
    روی دیسک ایجاد نمی‌شود. این کار نه تنها تمیزتر و ساده‌تر است، بلکه
    بسیار بهینه‌تر و سریع‌تر نیز عمل می‌کند.
  </p>
  <p>
    برای درک بهتر، فرض کنید می‌خواهیم لیست فایل‌های دایرکتوری
    <code>/etc</code> را ببینیم، اما چون لیست طولانی است، می‌خواهیم آن را
    صفحه به صفحه مشاهده کنیم. بدون پایپ باید این کار را می‌کردیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls /etc > tempfile.txt
$ less tempfile.txt
$ rm tempfile.txt
</pre>
  <p>
    اما با استفاده از پایپ، کل این سه مرحله به یک دستور واحد، خوانا و بهینه
    تبدیل می‌شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls /etc | less
</pre>
</section>
<section>
  <h2>فیلترها (Filters)</h2>
  <p>
    بسیاری از ابزارهای خط فرمان لینوکس به عنوان «فیلتر» طراحی شده‌اند.
    فیلتر برنامه‌ای است که ورودی خود را از <code>stdin</code> می‌خواند، نوعی پردازش
    (مانند مرتب‌سازی، شمارش، جستجو و...) روی آن انجام می‌دهد و نتیجه
    را در <code>stdout</code> می‌نویسد. این طراحی ماژولار باعث می‌شود که این
    ابزارها کاملاً برای استفاده در زنجیره‌های پایپ مناسب باشند.
  </p>
  <p>
    برخی از معروف‌ترین فیلترها که در ادامه دوره با بسیاری از آن‌ها
    آشنا خواهیم شد عبارتند از:
    <code>sort</code> (مرتب‌سازی)، <code>uniq</code> (حذف تکراری‌ها)،
    <code>grep</code> (جستجو)، <code>wc</code> (شمارش کلمات و خطوط)، <code>head</code> و
    <code>tail</code> (نمایش ابتدا و انتهای ورودی)، <code>tr</code> (جایگزینی کاراکترها) و
    بسیاری دیگر. قدرت واقعی خط فرمان زمانی آشکار می‌شود که شما یاد بگیرید
    چگونه این فیلترها را مانند قطعات لگو با استفاده از پایپ به هم متصل کنید.
  </p>
</section>
<section>
  <h2>مثال‌های کاربردی از Piping</h2>
  <p>بهترین راه برای درک قدرت پایپ، دیدن چند مثال عملی است.</p>

  <h3>مثال ۱: ترکیب ls و wc</h3>
  <p>
    فرض کنید می‌خواهیم تعداد فایل‌ها و دایرکتوری‌های موجود در
    پوشه‌ی <code>/usr/bin</code> را بشماریم. می‌توانیم خروجی دستور
    <code>ls</code> را به ورودی دستور <code>wc</code> (مخفف <b>w</b>ord <b>c</b>ount) بدهیم
    و با گزینه‌ی <code>-l</code> به آن بگوییم که فقط تعداد خطوط را بشمارد.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls /usr/bin | wc -l
2145
  </pre>
  <p>
    این دستور به ما می‌گوید که خروجی دستور <code>ls /usr/bin</code> دارای
    ۲۱۴۵ خط است که معادل تعداد آیتم‌های موجود در آن دایرکتوری است.
  </p>

  <h3>مثال ۲: زنجیره‌ی چندتایی برای پردازش متن</h3>
  <p>
    ما می‌توانیم هر تعداد دستوری را که بخواهیم با پایپ به هم متصل کنیم. فرض
    کنید فایلی به نام
    <code>fruits.txt</code> با محتوای زیر داریم:
  </p>
  <pre dir="ltr" data-cm-lang="text">
apple
banana
orange
apple
banana
apple
  </pre>
  <p>
    حالا می‌خواهیم یک لیست مرتب شده از میوه‌ها به همراه تعداد تکرار هر
    کدام را به دست آوریم. برای این کار یک زنجیره‌ی سه‌تایی
    می‌سازیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat fruits.txt | sort | uniq -c
      3 apple
      2 banana
      1 orange
  </pre>
  <p>در اینجا چه اتفاقی افتاد؟</p>
  <ol data-steps>
    <li>
      <code>cat fruits.txt</code> محتوای فایل را می‌خواند و به خروجی استاندارد
      خود می‌فرستد.
    </li>
    <li>
      خروجی <code>cat</code> به ورودی <code>sort</code> پایپ می‌شود. <code>sort</code> خطوط
      را مرتب کرده و نتیجه را به خروجی خود می‌فرستد.
    </li>
    <li>
      خروجی مرتب‌شده‌ی <code>sort</code> به ورودی <code>uniq -c</code> پایپ
      می‌شود. دستور <code>uniq</code> خطوط تکراری پشت سر هم را حذف می‌کند و
      گزینه‌ی <code>-c</code> باعث می‌شود تعداد تکرار هر خط را نیز شمارش
      کند.
    </li>
  </ol>

  <div data-callout="info">
    <strong>فلسفه‌ی یونیکس</strong>
    <p>
      این روش کار، یعنی ساختن ابزارهای ساده و تک‌منظوره که به خوبی با هم
      کار می‌کنند، هسته‌ی اصلی «فلسفه‌ی یونیکس» را تشکیل
      می‌دهد. این فلسفه می‌گوید:
    </p>
    <ul class="list-disc pr-6">
      <li>برنامه‌هایی بنویسید که یک کار را به خوبی انجام دهند.</li>
      <li>برنامه‌هایی بنویسید که با یکدیگر کار کنند.</li>
      <li>
        برنامه‌هایی بنویسید که جریان‌های متنی را مدیریت کنند، زیرا این
        یک رابط جهانی است.
      </li>
    </ul>
    <p>عملگر پایپ تجلی کامل این فلسفه در عمل است.</p>
  </div>
</section>
