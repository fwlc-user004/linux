<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    می‌رسیم به یکی از مهمترین ویژگی‌های لینوکس یعنی Redirection یا به بیان
    دقیق‌تر، <code>I/O Redirection</code> که به معنای تغییر رفتار پیش‌فرض سیستم‌های
    لینوکسی در کار با ورودی‌ها و خروجی‌هاست. بر اساس این رفتار پیش‌فرض، خروجی
    کامندها در صفحه‌ی ترمینال نمایش داده می‌شود و ورودی‌ها از کیبورد دریافت
    می‌شوند. اما می‌توانیم ترتیبی بدهیم که خروجی کامندها به جای نمایش در صفحه‌ی
    ترمینال، در یک فایل متنی ذخیره شود و یا ورودی کامندها به جای کیبورد، از یک
    فایل دریافت شود. علاوه بر این، در مورد مفهوم کلیدی <code>Piping</code> نیز صحبت
    خواهیم کرد که این امکان را فراهم می‌کند که خروجی یک کامند را به عنوان ورودی
    به یک کامند دیگر بدهیم. در این راستا با کامندهای مهمی مانند <code>cat</code>،
    <code>grep</code>، <code>head</code> و <code>tail</code> و چند کامند دیگر نیز آشنا
    خواهیم شد.
  </p>
</section>

<section>
  <h2>فایل‌های stdout، stdin و stderr</h2>
  <p>
    یک بار دیگر فلسفه و تم حاکم بر لینوکس را یادآوری می‌کنم:
    <b>در لینوکس، هر چیزی یک فایل است.</b> اما آیا رفتار پیش‌فرضی که لینوکس با
    اعمال I/O دارد، با این اصل سازگار است؟
  </p>
  <p>
    یک کامند می‌تواند با تولید خروجی مورد نظرش همراه باشد و یا اینکه خطا تولید
    کند. کامندهایی مانند <code>ls</code> نتایج خود را برای یک فایل خاص با نام
    <code>standard output</code> که به‌اختصار <code>stdout</code> نامیده می‌شود،
    ارسال می‌کنند و پیغام‌های خطا و گزارش وضعیتشان را به فایل خاصی به نام
    <code>standard error</code> یا <code>stderr</code> ارسال می‌کنند. از آنجایی
    که هر دوی این فایل‌ها در حالت پیش‌فرض به صفحه‌ی ترمینال لینک هستند،
    این خروجی‌ها در ترمینال نمایش داده می‌شود. در واقع، علت اینکه از لفظ خاص
    برای این دو فایل استفاده کردیم، این است که اینها فایل‌های ذخیره شده در دیسک
    نیستند، بلکه به صفحه‌ی ترمینال لینک هستند.
  </p>
  <p>
    به علاوه، اکثر کامندها ورودی مورد نیاز خود را از فایلی به نام
    <code>standard input</code> یا <code>stdin</code> دریافت می‌کنند که در حالت
    پیش‌فرض به کیبورد لینک است.
  </p>
  <p>
    I/O Redirection به ما امکان می‌دهد که این رفتارهای پیش‌فرض را تغییر دهیم و
    خروجی را به جایی غیر از ترمینال هدایت کنیم و ورودی را از منبعی غیر از کیبورد
    دریافت کنیم. این کار به منزله‌ی ریدایرکت فایل‌های <code>stdout</code>،
    <code>stderr</code> و <code>stdin</code> است که نحوه‌ی انجام آن را در ادامه
    خواهیم دید.
  </p>
</section>

<section>
  <h2>ریدایرکت stdout</h2>
  <p>
    با <code>stdout</code> شروع می‌کنیم که همانطور که گفته شد، فایلی است که اکثر
    کامندهای لینوکسی، خروجی خود را برای آن ارسال می‌کنند و چون این فایل در حالت
    پیش‌فرض به صفحه‌ی ترمینال لینک است، خروجی کامندها در ترمینال نمایش داده
    می‌شود.
  </p>
  <p>
    اما ریدایرکت <code>stdout</code> به این معناست که ترتیبی دهیم تا این فایل به
    جای ترمینال، به یک فایل متنیِ ذخیره شده روی دیسک لینک شود و نتیجتاً خروجی
    کامندها (به جای نمایش در ترمینال) در آن فایل متنی ذخیره شود. این کار با
    استفاده از عملگر ریدایرکت <code>stdout</code> که با <code>&gt;</code> نمایش
    داده می‌شود، قابل انجام است. در مثال زیر، از این عملگر استفاده کرده‌ایم تا
    خروجی کامند <code>ls</code> به‌جای نمایش در ترمینال، در فایلی با نام
    <code>output.txt</code> ذخیره شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l > output.txt
</pre>
  <p>
    با اجرای این کامند، اگر فایل <code>output.txt</code> موجود نباشد، ساخته
    می‌شود و خروجی کامند <code>ls -l</code> در آن ذخیره می‌شود. اگر هم این فایل
    از قبل موجود باشد، محتوای آن حذف شده و با خروجی کامند <code>ls -l</code>
    بازنویسی می‌شود. در هر صورت، اگر محتوای فایل <code>output.txt</code> را با
    استفاده از کامند <code>less</code> نمایش دهیم، خواهیم دید که خروجی کامند
    <code>ls -l</code> در این فایل ذخیره شده است.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ less output.txt
</pre>
  <p>
    دقت داشته باشید که عملگر <code>&gt;</code> فقط فایل <code>stdout</code> را
    ریدایرکت می‌کند و ریدایرکت <code>stderr</code> به عملگر دیگری نیاز دارد که
    در ادامه، آن را خواهیم دید. بنابراین، اگر کامند <code>ls</code> بالا را طوری
    بنویسیم که با یک خطا همراه باشد، پیغام خطا همچنان در ترمینال نمایش داده
    می‌شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -e > output.txt
ls: invalid option -- 'e'
Try 'ls --help' for more information.
  </pre>
  <p>
    در این کامند از یک آپشن <code>-e</code> برای کامند <code>ls</code> استفاده
    شده اما <code>ls</code> فاقد چنین آپشنی است و بنابراین، یک پیغام خطا تولید
    شده و در ترمینال نمایش داده شده است. باز هم تکرار می‌کنم که نباید انتظار
    داشته باشید که این پیغام خطا در فایل <code>output.txt</code> ذخیره شود؛ چون
    عملگر <code>&gt;</code> فایل <code>stdout</code> را ریدایرکت می‌کند اما
    پیغام‌های خطا به فایل <code>stderr</code> ارسال می‌شوند.
  </p>
  <p>
    اما اگر الان یک بار دیگر محتوای فایل <code>output.txt</code> را با کامند
    <code>less</code> نمایش دهید، خواهید دید که این فایل خالی شده و محتوایی
    ندارد. چون همانطور که در بالا اشاره کردیم، وقتی ما خروجی را با استفاده از
    عملگر <code>&gt;</code> ریدایرکت می‌کنیم، فایل مقصد همیشه بازنویسی می‌شود.
    یعنی در اینجا فایل <code>output.txt</code> خالی می‌شود تا محتوای جدید را
    دریافت کند اما وقوع خطا باعث می‌شود که محتوایی برای این فایل ارسال نشود و در
    عوض، پیغام خطای تولید شده به <code>stderr</code> ارسال شود.
  </p>
  <p>
    به نظرتان نتیجه‌ی اجرای کامند <code>&gt; test.txt</code> چیست؟ گفتیم که
    عملگر <code>&gt;</code> همیشه فایل مقصد را بازنویسی می‌کند. پس، در اینجا
    محتوای فایل <code>test.txt</code> حذف می‌شود اما چون قبل از عملگر
    <code>&gt;</code> چیزی وجود ندارد، بازنویسی انجام نخواهد شد و نتیجتاً فایل
    خالی می‌ماند. پس، این کامند باعث می‌شود که فایل <code>test.txt</code> در
    صورت وجود، خالی شود و اگر موجود نباشد، ساخته شود. از این ترفند می‌توانیم
    برای ساخت یک فایل خالی یا حذف محتوای یک فایل استفاده کنیم.
  </p>

  <h3>ریدایرکت بدون بازنویسی</h3>
  <p>
    عملگر ریدایرکت <code>stdout</code> یک ورژن دیگر هم دارد که با
    <code>&gt;&gt;</code> نمایش داده می‌شود. این عملگر، به جای بازنویسی فایل
    مقصد، خروجی کامند را به آن اضافه (append) می‌کند.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ date > output.txt
$ pwd >> output.txt 
$ less output.txt
Wed Sep 25 12:03:09 +0330 2024
/home/hagrid
</pre>
  <p>
    در اینجا کامند اول باعث می‌شود که فایل <code>output.txt</code> با خروجی
    کامند <code>date</code> بازنویسی شود. در واقع، اگر فایل
    <code>output.txt</code> وجود نداشته باشد، ساخته می‌شود و خروجی کامند
    <code>date</code> در آن ذخیره می‌شود و اگر این فایل موجود باشد، با خروجی
    کامند <code>date</code> بازنویسی می‌شود. اما در کامند دوم از عملگر
    <code>&gt;&gt;</code> استفاده شده که باعث می‌شود خروجی کامند <code>pwd</code>
    به فایل <code>output.txt</code> اضافه شود.
  </p>
</section>
<section>
  <h2>ریدایرکت stderr</h2>
  <p>
    هر یک از فایل‌های <code>stdout</code>، <code>stdin</code> و <code>stderr</code> دارای یک عدد موسوم به
    file descriptor هستند. این عدد برای <code>stdout</code> برابر با 0، برای <code>stdin</code> برابر با
    1 و برای <code>stderr</code> برابر با 2 است. برای ریدایرکت <code>stderr</code> باید از عدد متناظر آن
    یعنی 2 قبل از عملگر <code>&gt;</code> استفاده کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cd /hello/bye 2> error.txt
  </pre>
  <p>
    در اینجا از مسیری برای کامند <code>cd</code> استفاده کرده‌ایم که وجود خارجی ندارد و
    بنابراین، خروجی این کامند، یک پیغام خطاست. در غیاب عملگر ریدایرکت <code>stderr</code>،
    این پیغام در ترمینال نمایش داده می‌شود اما چون در اینجا با استفاده از عملگر
    <code>2&gt;</code> فایل <code>stderr</code> را ریدایرکت کرده‌ایم، پیغام خطا در فایلی به نام
    <code>error.txt</code> ذخیره خواهد شد.
  </p>
  <p>
    مثل قبل، اگر فایل مقصد وجود نداشته باشد، ساخته می‌شود و در صورت وجود،
    بازنویسی خواهد شد. اما اگر بخواهیم ریدایرکت به گونه‌ای باشد که به جای
    بازنویسی فایل مقصد، پیغام خروجی به آن فایل اضافه شود، باید از عملگر
    <code>2&gt;&gt;</code> به جای <code>2&gt;</code> استفاده کنیم.
  </p>

  <h3>ریدایرکت stdout و stderr به یک فایل</h3>
  <p>
    گاهی اوقات می‌خواهیم خروجی یک کامند، چه از نوع مورد انتظار باشد و چه یک
    پیغام خطا، در هر دو صورت در یک فایل یکسان ذخیره شود. در این صورت، باید هر دو
    فایل <code>stdout</code> و <code>stderr</code> را به یک فایل یکسان ریدایرکت کنیم. برای این کار،
    می‌توانیم از عملگر <code>&amp;&gt;</code> استفاده کنیم. مثال زیر را ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l /usr/bin &> output.txt
  </pre>
  <p>
    و اگر بخواهیم فایل مقصد بازنویسی نشود، باید به جای <code>&amp;&gt;</code> از
    عملگر <code>&amp;&gt;&gt;</code> استفاده کنیم.
  </p>

  <h3>جلوگیری از نمایش و ذخیره خروجی</h3>
  <p>
    ممکن است گاهی بخواهیم ترتیبی دهیم که پیغام‌های خطا نه در ترمینال نمایش داده
    شوند و نه در فایلی ذخیره شوند. در لینوکس، یک فایل خاص با نام
    <code>/dev/null</code> وجود دارد که دقیقاً همین کار را انجام می‌دهد؛ یعنی
    خروجی کامند را نیست و نابود می‌کند. کافیست کامند مورد نظر را به این فایل
    ریدایرکت کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l /hello/world 2> /dev/null
  </pre>
  <p>
    در اینجا کامند <code>ls</code> آرگومان نامعتبری (یک دایرکتوری ناموجود) دریافت کرده و
    بنابراین، با خطا همراه است. اما چون فایل <code>stderr</code> را به
    <code>/dev/null</code> ریدایرکت کرده‌ایم، پیغام خطا نمایش داده نمی‌شود و ذخیره
    هم نمی‌شود. پس، با اجرای این کامند، هیچ اتفاقی نمی‌افتد.
  </p>
</section>

<section>
  <h2>ریدایرکت stdin</h2>
  <p>
    قبل از اینکه در مورد ریدایرکت <code>stdin</code> صحبت کنیم، ابتدا یک کامند جدید با نام
    <code>cat</code> را معرفی می‌کنیم. این کامند که نامش از روی واژه‌ی <i>concatenate</i> به معنای
    الحاق و ادغام، گرفته شده، یک یا چند فایل را می‌خواند و آنها را در <code>stdout</code> کپی
    می‌کند. اگر فقط یک فایل را به عنوان آرگومان این متد تعیین کنیم، محتوای این
    فایل در ترمینال نمایش داده می‌شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat /etc/passwd
  </pre>
  <p>
    اگر این کامند را اجرا کنید، خواهید دید که محتویات فایل
    <code>/etc/passwd</code> در ترمینال نمایش داده می‌شود. پس، تا اینجا کامند <code>cat</code>
    مثل کامند <code>less</code> محتوای فایل را در ترمینال نمایش می‌دهد اما با این تفاوت که
    <code>cat</code> قادر به صفحه‌بندی محتوا نیست. اما در عوض، <code>cat</code> می‌تواند بیش از یک فایل را
    به عنوان آرگومان دریافت کند، آنها را با هم ادغام کند و نتیجه را در ترمینال
    نمایش دهد. به مثال زیر توجه کنید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ echo "Hello" > greeting1
$ echo "How are you?" > greeting2
$ cat greeting1 greeting2
Hello 
How are you? 
$ cat greeting1 greeting2 > greeting
$ cat greeting
Hello
How are you?
  </pre>

  <p>
    اگر کامند <code>cat</code> را بدون آرگومان اجرا کنیم، منتظر دریافت ورودی از <code>stdin</code>
    می‌ماند. سپس، هر مقداری را که از طریق کیبورد وارد کنیم، نمایش می‌دهد و
    آماده‌ی دریافت ورودی بعدی می‌شود. این رویه ادامه خواهد داشت تا زمانی که
    کلیدهای <kbd>CTRL-D</kbd> را فشار دهیم. کامند <code>cat</code> را در ترمینال وارد کنید
    تا این مورد را در عمل ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat
The quick brown fox jumped over the lazy dog. 
The quick brown fox jumped over the lazy dog.
Hello
Hello
  </pre>
  <p>
    در واقع، کاری که <code>cat</code> در غیاب یک آرگومان انجام می‌دهد، این است که <code>stdin</code> را
    در <code>stdout</code> کپی می‌کند. بنابراین، می‌توانیم از روش زیر برای ساخت یک فایلِ
    دارای محتوای متنیِ مختصر استفاده کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
  </pre>
  <p>
    حالا می‌توانیم به بحث ریدایرکت <code>stdin</code> بپردازیم که با استفاده از عملگر
    <code>&lt;</code> قابل انجام است. این عملگر <code>stdin</code> را ریدایرکت می‌کند و
    بنابراین، می‌توان با استفاده از آن ترتیبی داد که یک کامند، ورودی خود را به
    جای کیبورد از یک فایل دریافت کند.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog
  </pre>
  <p>
    در اینجا کامند <code>cat</code> ورودی خود را از فایل <code>lazy_dog.txt</code> دریافت کرده و آن را
    نمایش داده است. البته در مورد کامند <code>cat</code> دیدیم که بدون استفاده از عملگر
    <code>&lt;</code> هم می‌توان این کار را انجام داد اما بعداً کامندهایی خواهیم
    دید که استفاده‌های بهتری از این عملگر می‌کنند.
  </p>
</section>
<section>
  <h2>نقش عملگر Pipe</h2>
  <p>
    Piping یک ویژگی شِل است که به ما امکان می‌دهد خروجی یک دستور را به عنوان ورودی به یک دستور دیگر بدهیم. در
    واقع، پایپینگ نوعی ریدایرکت را انجام می‌دهد. عملگر پایپ (<code>|</code>) برای پیاده‌سازی این نوع ریدایرکت کاربرد دارد.
  </p>
  <p>
    تا الان از کامند <code>less</code> برای نمایش محتوای فایل‌ها به صورت صفحه‌بندی‌شده استفاده کرده‌ایم
    اما آیا می‌توانیم آن را برای نمایش خروجی کامندها هم به کار بگیریم؟ این کار را می‌توانیم با تکیه بر تکنیک پایپینگ و عملگر پایپ
    انجام دهیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l /usr/bin | less
  </pre>
  <p>
    اگر این کامند را اجرا کنید، خواهید دید که خروجی کامند <code>ls</code> توسط <code>less</code>
    نمایش داده می‌شود. در واقع، <code>less</code> خروجی هر
    کامندی را که نتایجش را برای stdout می‌فرستد، به عنوان ورودی دریافت می‌کند. این یک ویژگی بسیار مفید و
    به‌دردبخور است؛ چون به ما امکان می‌دهد که خروجی هر کامندی را به صورت صفحه‌بندی‌شده ببینیم.
  </p>

  <h3>فیلترها</h3>
  <p>
    از عملگر پایپ معمولاً برای انجام کارهای پیچیده‌تر روی داده‌ها استفاده می‌شود. با استفاده از این عملگر
    می‌توانیم چندین کامند را با هم ترکیب کنیم؛ به نحوی که هر کامند ورودی را دریافت کند، کاری روی آن انجام دهد و
    خروجی حاصل‌شده را به کامند بعدی بدهد. کامندهای موجود در یک چنین زنجیره‌ای را فیلتر (Filter) می‌نامند.
  </p>
  <p>
    یکی از کامندهایی که زیاد به عنوان فیلتر به کار می‌رود، کامند <code>sort</code> است که همانطور که از
    نامش پیداست، ورودی خود را مرتب می‌کند. در مثال زیر از این کامند استفاده شده است.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat > asian_countries
Iran
Japan
China
Kuwait
Turkey
South Korea
$ cat > european_countries
England
Germany
Italy
Turkey
Spain
$ cat asian_countries european_countries | sort | less
China
England
Germany
Iran
Italy
Japan
Kuwait
South Korea
Spain
Turkey
Turkey
  </pre>
  <p>
    در این مثال، ابتدا نام چند کشور آسیایی را در فایلی به نام <code>asian_countries</code> و نام چند کشور اروپایی را
    در فایلی به نام <code>european_countries</code> ذخیره کرده‌ایم. سپس، با استفاده از تکنیک پایپینگ، این دو فایل را ترکیب کرده
    و خروجی را به کامند <code>sort</code> داده‌ایم. کامند <code>sort</code> ورودی خود را مرتب کرده و
    آن را به کامند <code>less</code> می‌دهد و <code>less</code> هم
    این ورودی را نمایش می‌دهد.
  </p>
  <p>
    یک فیلتر دیگر که معمولاً به همراه کامند <code>sort</code> به کار می‌رود، کامند <code>uniq</code> است که خطوط تکراری در ورودی خود را
    حذف می‌کند.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat asian_countries european_countries | sort | uniq | less
</pre>
  <p>
    در اینجا کامند <code>uniq</code> به عنوان یک فیلتر به زنجیره‌ی کامندها اضافه شده و در لیست
    مرتب‌شده‌ای که از کامند <code>sort</code> تحویل می‌گیرد، خطوط تکراری را حذف می‌کند و نتیجه را به کامند <code>less</code> می‌دهد.
    خروجی به صورت زیر خواهد بود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
China
England
Germany
Iran
Italy
Japan
Kuwait
South Korea
Spain
Turkey
</pre>
  <p>
    اگر بخواهیم به جای حذف خطوط تکراری، آنها را ببینیم، باید مانند زیر از آپشن <code>-d</code>
    استفاده کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cat asian_countries european_countries | sort | uniq -d | less
</pre>
</section>
<section>
  <h2>دریافت اطلاعات فایل‌ها</h2>
  <p>
    در این بخش با چند کامند مفید که برای استخراج اطلاعات از فایل‌ها کاربرد
    دارند، آشنا می‌شویم. این کامندها عبارتند از:
  </p>
  <ul>
    <li>
      کامند <code>wc</code> برای دریافت تعداد خطوط، کلمات و بایت‌ها در یک فایل.
    </li>
    <li>
      کامند <code>grep</code> برای پیدا کردن عباراتِ دارای یک الگوی مشخص در یک
      فایل.
    </li>
    <li><code>head</code> برای نمایش خطوط ابتدایی یک فایل.</li>
    <li><code>tail</code> برای نمایش خطوط انتهایی یک فایل.</li>
  </ul>

  <h3>کامند wc</h3>
  <p>
    کامند <code>wc</code> تعداد خطوط، کلمات و بایت‌های یک فایل را محاسبه کرده و نمایش
    می‌دهد. در مثال زیر از این کامند برای فایل <code>/etc/passwd</code> استفاده
    شده است.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ wc /etc/passwd
28   38 1473 /etc/passwd
  </pre>
  <p>
    که نشان می‌دهد در این فایل 28 خط و 38 کلمه و 1473 بایت وجود دارد. در
    فایل‌هایی که فقط از کاراکترهای ASCII تشکیل شده باشند، تعداد بایت‌ها
    نشان‌دهنده‌ی تعداد کاراکترهاست.
  </p>
  <p>
    اگر فقط تعداد خطوط یک فایل را بخواهیم، می‌توانیم از آپشن
    <code>-l</code> برای کامند wc استفاده کنیم. آپشن‌های <code>-w</code> و
    <code>-c</code> هم به‌ترتیب برای نمایش تعداد کلمات و تعداد کاراکترها کاربرد
    دارند.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ wc -l /etc/passwd
28 /etc/passwd
  </pre>

  <h3>کامند grep</h3>
  <p>
    کامند <code>grep</code> برای پیدا کردن خطوطی از یک فایل که شامل عبارتی با یک الگوی مشخص
    هستند، کاربرد دارد. برای مثال، فرض کنید بخواهیم از لیست برنامه‌هایی که در
    دایرکتوری‌های <code>/bin</code> و <code>/usr/bin</code> قرار دارند، هر کدام را
    که شامل عبارت zip هستند، چاپ کنیم. این کار به صورت زیر قابل انجام است.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls /bin /usr/bin | sort | uniq | grep zip
  </pre>
  <p>
    از آنجایی که ممکن است برنامه‌ای داشته باشیم که هم در دایرکتوری
    <code>/bin</code> و هم در دایرکتوری <code>/usr/bin</code> باشد، از فیلترهای
    sort و uniq برای مرتب‌سازی و حذف نام برنامه‌های تکراری استفاده کرده‌ایم.
  </p>
  <p>برای کامند grep دو آپشن مفید داریم:</p>
  <ul>
    <li>
      آپشن <code>-i</code> که باعث می‌شود هنگام جستجوی فایل، بزرگی و کوچکی حروف
      در نظر گرفته نشود؛ یعنی برای مثال، test و Test دو عبارت یکسان در نظر
      گرفته شوند. در غیاب این آپشن، جستجو به صورت حساس به حروف (case
      sensitive) انجام می‌شود.
    </li>
    <li>
      آپشن <code>-v</code> که نتیجه‌ی جستجو را معکوس می‌کند؛ یعنی باعث می‌شود
      خطوطی چاپ شوند که با الگوی مورد نظر مطابقت ندارند.
    </li>
  </ul>

  <h3>کامندهای head و tail</h3>
  <p>
    گاهی اوقات فقط به چند خط ابتدایی یا چند خط انتهایی یک فایل نیاز داریم. در
    این مواقع، می‌توانیم از کامندهای <code>head</code> و <code>tail</code> استفاده کنیم که اولی، 10 خط
    ابتدایی و دومی، 10 خط انتهایی فایل را نمایش می‌دهند. البته با استفاده از
    آپشن <code>-n</code> می‌توانیم تعداد خطوط را از عدد پیش‌فرض 10 به هر عدد
    دیگر تغییر دهیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ head -n 3 asian_countries
Iran
Japan
China

$ tail -n 2 asian_countries
Turkey
South Korea
  </pre>
  <p>
    حالا اجازه دهید یک کاربرد جالب از این کامندها را در عمل ببینیم. فرض کنید
    می‌خواهیم مدل CPU کامپیوترمان را پیدا کنیم. در اکثر توزیع‌های لینوکسی،
    کامندی با نام <code>lscpu</code> داریم که مشخصات کاملی از CPU را ارائه می‌دهد. اگر این
    کامند را اجرا کنید، خواهید دید که در خط هشتمِ خروجی، که با عبارت <code>Model
    name</code> شروع می‌شود، اطلاعات مورد نظر ما ارائه شده است. حالا می‌خواهیم با
    ترکیب چند کامند با تکنیک پایپینگ، این خط را در خروجی نمایش دهیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ lscpu | head -n 8 | tail -n 1 | less
  </pre>
  <p>چیزی شبیه خروجی زیر توسط less نمایش داده خواهد شد:</p>
  <pre>
Model name:                         Intel(R) Core(TM) i7-4700HQ CPU @ 2.40GHz
  </pre>
</section>
