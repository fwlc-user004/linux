<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    در درس قبل، اولین قدم‌ها را در دنیای اسکریپت‌نویسی برداشتیم و یاد گرفتیم که
    چگونه دستورات را به صورت خطی و پشت سر هم اجرا کنیم. اما قدرت واقعی
    برنامه‌نویسی زمانی آشکار می‌شود که یک برنامه بتواند بر اساس شرایط مختلف،
    تصمیم‌های متفاوتی بگیرد. اگر بخواهیم یک عمل خاص، تنها در صورتی که یک شرط
    برقرار باشد انجام شود، چه باید بکنیم؟
  </p>
  <p>
    اینجاست که ساختارهای شرطی، و در رأس آن‌ها دستور if، وارد میدان می‌شوند.
    دستور if به اسکریپت‌های ما قابلیت افزودن منطق و انشعاب را می‌دهد. با استفاده
    از آن، اسکریپت‌های ما از یک دنباله‌ی ثابت از دستورات، به برنامه‌های هوشمندی
    تبدیل می‌شوند که می‌توانند به ورودی‌ها و شرایط مختلف واکنش‌های متناسب نشان
    دهند.
  </p>
</section>
<section>
  <h2>دستور if و کدهای خروج (Exit Codes)</h2>
  <p>
    برای درک عملکرد if در شل، ابتدا باید با یک مفهوم بنیادی آشنا شویم: کد خروج.
    هر دستوری که در لینوکس اجرا می‌شود، پس از پایان کار خود یک عدد صحیح به نام
    «کد خروج» را به سیستم برمی‌گرداند. این عدد وضعیت نهایی اجرای دستور را مشخص
    می‌کند:
  </p>
  <ul class="list-disc pr-6">
    <li>
      <b>کد خروج 0:</b> به معنای موفقیت کامل است. دستور بدون هیچ مشکلی کار خود
      را انجام داده است.
    </li>
    <li>
      <b>کد خروج غیر صفر (از ۱ تا ۲۵۵):</b> به معنای بروز یک خطا یا شکست است.
    </li>
  </ul>
  <p>
    ساختار if در شل، برخلاف بسیاری از زبان‌های برنامه‌نویسی، یک عبارت را به true
    یا false ارزیابی نمی‌کند. در عوض، یک دستور را اجرا کرده و کد خروج آن را
    بررسی می‌کند. اگر کد خروج 0 (موفقیت) بود، بلوک دستورات بعد از then اجرا
    می‌شود.
  </p>

  <pre dir="ltr" data-cm-lang="bash">
if some_command
then
  echo "Command was successful."
fi
</pre
  >

  <p>
    شما می‌توانید کد خروج آخرین دستور اجرا شده را همیشه با متغیر خاص $? مشاهده
    کنید:
  </p>

  <pre dir="ltr" data-cm-lang="bash">
$ ls /etc/passwd; echo $?
/etc/passwd
0
$ ls /not/a/real/file; echo $?
ls: cannot access '/not/a/real/file': No such file or directory
2
</pre
  >
</section>
<section>
  <h2>دستور test و شرط‌ها</h2>
  <p>
    حال سؤال اینجاست: چگونه می‌توانیم شرایطی مانند «آیا این عدد بزرگتر از ۱۰
    است؟» یا «آیا این فایل وجود دارد؟» را بررسی کنیم؟ این‌ها که دستور نیستند!
    پاسخ، استفاده از دستور test است. وظیفه این دستور، ارزیابی یک عبارت شرطی و
    برگرداندن کد خروج 0 در صورت درست بودن شرط، و کد خروج 1 در صورت غلط بودن آن
    است.
  </p>
  <p>
    امروزه به جای نوشتن خود کلمه‌ی test، از معادل آن یعنی براکت‌ها استفاده
    می‌شود. فرم مدرن و توصیه‌شده، استفاده از دو براکت [[ ... ]] است که
    قابلیت‌های بیشتر و امنیت بهتری نسبت به تک براکت [ ... ] دارد.
  </p>

  <h3>آزمون‌های رایج</h3>
  <p>
    در جدول زیر، برخی از رایج‌ترین آزمون‌های شرطی که در اسکریپت‌های شل استفاده
    می‌شوند را مشاهده می‌کنید. این آزمون‌ها به شما اجازه می‌دهند تا رشته‌ها،
    اعداد و فایل‌ها را بررسی کنید و منطق مورد نیاز خود را پیاده‌سازی نمایید.
  </p>
  <table>
    <thead>
      <tr>
        <th>نوع آزمون</th>
        <th>عبارت</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">رشته‌ها (Strings)</td>
        <td>[[ "$str1" == "$str2" ]]</td>
        <td>آیا دو رشته مساوی هستند.</td>
      </tr>
      <tr>
        <td>[[ "$str1" != "$str2" ]]</td>
        <td>آیا دو رشته نامساوی هستند.</td>
      </tr>
      <tr>
        <td>[[ -z "$str" ]]</td>
        <td>آیا رشته خالی است (طول صفر دارد).</td>
      </tr>
      <tr>
        <td rowspan="3">اعداد (Numbers)</td>
        <td>[[ "$num" -eq "10" ]]</td>
        <td>مساوی (equal)</td>
      </tr>
      <tr>
        <td>[[ "$num" -gt "10" ]]</td>
        <td>بزرگتر از (greater than)</td>
      </tr>
      <tr>
        <td>[[ "$num" -lt "10" ]]</td>
        <td>کوچکتر از (less than)</td>
      </tr>
      <tr>
        <td rowspan="3">فایل‌ها (Files)</td>
        <td>[[ -e "$path" ]]</td>
        <td>آیا فایل یا دایرکتوری وجود دارد (exists).</td>
      </tr>
      <tr>
        <td>[[ -f "$path" ]]</td>
        <td>آیا یک فایل عادی است (file).</td>
      </tr>
      <tr>
        <td>[[ -d "$path" ]]</td>
        <td>آیا یک دایرکتوری است (directory).</td>
      </tr>
    </tbody>
  </table>

  <div data-callout="info">
    <p>
      همیشه متغیرهای خود را داخل دابل کوتیشن ("") قرار دهید. این کار از بروز خطا
      در صورتی که متغیر خالی باشد یا حاوی فاصله باشد، جلوگیری می‌کند.
    </p>
  </div>
</section>

<section>
  <h2>ساختن دستورات if کامل</h2>
  <p>اکنون می‌توانیم با ترکیب if و [[ ... ]]، اسکریپت‌های هوشمند بنویسیم.</p>

  <h3>اضافه کردن else و elif</h3>
  <p>ساختار if می‌تواند شامل دو بخش دیگر نیز باشد:</p>
  <ul class="list-disc pr-6">
    <li>
      <b>else:</b> بلوک دستوراتی که در صورت برقرار نبودن شرط if اجرا می‌شود.
    </li>
    <li>
      <b>elif (else if):</b> به ما اجازه می‌دهد تا شرط‌های متعددی را پشت سر هم
      بررسی کنیم.
    </li>
  </ul>

  <p>اسکریپت زیر یک مثال کامل است که تمام این مفاهیم را به کار می‌گیرد:</p>

  <pre dir="ltr" data-cm-lang="bash">
#!/bin/bash

if [[ -z "$1" ]]; then
  echo "Error: No input file provided."
  exit 1 
fi

if [[ -f "$1" ]]; then
  echo "'$1' is a regular file."
elif [[ -d "$1" ]]; then
  echo "'$1' is a directory."
else
  echo "'$1' does not exist or is of another type."
fi
</pre
  >

  <div data-callout="info">
    <strong>آرگومان‌های خط فرمان و خروج از اسکریپت</strong>
    <p>در مثال بالا از دو مفهوم جدید استفاده کردیم:</p>
    <ul class="list-disc pr-6">
      <li>
        <b>$1:</b> این یک متغیر خاص به نام «پارامتر موقعیتی» است. $1 به اولین
        آرگومانی که جلوی نام اسکریپت در خط فرمان تایپ می‌شود اشاره دارد، $2 به
        دومی و الی آخر. (مثلاً در ./script.sh /etc/passwd، مقدار $1 برابر با
        /etc/passwd خواهد بود.)
      </li>
      <li>
        <b>exit 1:</b> این دستور، اجرای اسکریپت را فوراً متوقف کرده و کد خروج ۱
        (به معنای خطا) را برمی‌گرداند. این کار برای مدیریت خطاها بسیار مفید است.
      </li>
    </ul>
  </div>
</section>
