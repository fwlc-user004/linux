<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    در این درس با ۵ مورد از پرکاربردترین کامندهای لینوکس آشنا می‌شویم. این
    کامندها که به ویرایش فایل‌ها و دایرکتوری‌ها مربوطند، عبارتند از: کامند cp
    برای کپی‌کردن فایل‌ها و دایرکتوری‌ها، کامند mv برای انتقال (move) و تغییر
    نام (rename) فایل‌ها و دایرکتوری‌ها، کامند mkdir برای ایجاد دایرکتوری، کامند
    rm برای حذف فایل‌ها و دایرکتوری‌ها و کامند ln برای ساخت لینک‌ها. خیلی از
    کارهایی که این کامندها انجام می‌دهند، در محیط گرافیکی هم به‌راحتی قابل انجام
    است اما با استفاده از خط فرمان و کامندهایی که نام بردیم، می‌توانیم کارهایی
    را که انجامشان در محیط گرافیکی خیلی مشکل و زمان‌بر است، به سادگی و در کمترین
    زمان ممکن انجام دهیم. فرض کنید بخواهیم فایل‌های HTML درون یک دایرکتوری را به
    یک دایرکتوری دیگر کپی کنیم اما فقط آن فایل‌هایی را که در دایرکتوری مقصد وجود
    ندارند و یا اینکه نسبت به نسخه‌ی موجود تغییر کرده‌اند. انجام این کار به‌صورت
    گرافیکی زمان‌بر و خسته‌کننده است و به کار زیادی نیاز دارد اما در خط فرمان
    این کار به سادگی نوشتن یک کامند مثل cp -u *.html destination است.
  </p>
</section>

<section>
  <h2>کاراکترهای Wildcard</h2>
  <p>
    قبل از معرفی کامندهای مربوط به ویرایش فایل‌ها و دایرکتوری‌ها ابتدا با یک
    ویژگی مربوط به شِل آشنا می‌شویم که بخشی از قدرت کامندها مرهون این ویژگی است.
    کاراکترهای wildcard به ما امکان می‌دهند که فایل‌ها را بر اساس الگوهای پیچیده
    انتخاب کنیم. برای مثال، اگر بخواهیم همه‌ی فایل‌های HTML موجود در یک
    دایرکتوری را انتخاب کنیم، می‌توانیم از عبارت *.html به عنوان نام فایل
    استفاده کنیم که از یک کاراکتر wildcard یعنی * استفاده می‌کند.
  </p>
  <table>
    <thead>
      <tr>
        <th>کاراکتر Wildcard</th>
        <th>توضیح</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>*</td>
        <td>این wildcard با یک یا چند کاراکتر دلخواه مطابقت دارد.</td>
      </tr>
      <tr>
        <td>?</td>
        <td>این wildcard با یک کاراکتر دلخواه مطابقت دارد.</td>
      </tr>
      <tr>
        <td>[characters]</td>
        <td>
          این wildcard با هر کاراکتری که به مجموعه کاراکترهای بین [ ] تعلق دارد،
          مطابقت دارد.
        </td>
      </tr>
      <tr>
        <td>[!characters]</td>
        <td>
          این wildcard با هر کاراکتری که به مجموعه کاراکترهای بین [ ] تعلق
          ندارد، مطابقت دارد.
        </td>
      </tr>
      <tr>
        <td>[[:class:]]</td>
        <td>
          عبارت class نشان دهنده‌ی مجموعه‌ی مشخصی از کاراکترهاست و این wildcard
          با هر کاراکتر از این مجموعه مطابقت دارد.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    برای درک صحیح نقش کاراکترهای wildcard باید آنها را در چند مثال ببینیم. جدول
    زیر این مثال‌ها را ارائه می‌دهد.
  </p>
  <table>
    <thead>
      <tr>
        <th>الگوی نمونه</th>
        <th>نتیجه</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>*</td>
        <td>همه‌ی فایل‌ها انتخاب می‌شوند.</td>
      </tr>
      <tr>
        <td>g*</td>
        <td>هر فایلی که نامش با g شروع شود، انتخاب می‌شود.</td>
      </tr>
      <tr>
        <td>b*.txt</td>
        <td>
          هر فایلی که نامش با b شروع شده و به .txt ختم شده، انتخاب می‌شود.
        </td>
      </tr>
      <tr>
        <td>Data???</td>
        <td>
          هر فایلی که نامش از عبارت Data و سه کاراکتر بعد از آن تشکیل شده باشد،
          انتخاب می‌شود.
        </td>
      </tr>
      <tr>
        <td>[abc]*</td>
        <td>
          هر فایلی که نامش با یکی از کاراکترهای a، b یا c شروع شده باشد، انتخاب
          می‌شود.
        </td>
      </tr>
      <tr>
        <td>Backup.[0-9][0-9][0-9]</td>
        <td>
          هر فایلی که نامش از عبارت Backup. و یک عدد سه‌رقمی تشکیل شده باشد،
          انتخاب می‌شود.
        </td>
      </tr>
      <tr>
        <td>[[:upper:]]*</td>
        <td>هر فایلی که نامش با یک حرف بزرگ شروع شده باشد، انتخاب می‌شود.</td>
      </tr>
      <tr>
        <td>[![:digit:]]*</td>
        <td>هر فایلی که نامش با یک عدد شروع نشده باشد، انتخاب می‌شود.</td>
      </tr>
      <tr>
        <td>*[[:lower:]123]</td>
        <td>
          هر فایلی که نامش با یک حرف کوچک یا یکی از اعداد 1، 2 یا 3 تمام شده
          باشد، انتخاب می‌شود.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    در آخرین مثال جدول بالا از [:lower:] استفاده شده که یکی از حالت‌های ممکن
    برای [:class:] است و هر کاراکتر که به صورت lowercase یا حرف کوچک باشد، با آن
    مطابقت دارد. جدول زیر شامل سایر کلاس‌هایی است که می‌توانند علاوه بر lower
    مورد استفاه قرار گیرند.
  </p>
  <table>
    <thead>
      <tr>
        <th>کلاس</th>
        <th>معنی</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>[:alnum:]</td>
        <td>مجموعه کاراکترهای الفبایی و عددی</td>
      </tr>
      <tr>
        <td>[:alpha:]</td>
        <td>مجموعه کاراکترهای الفبایی</td>
      </tr>
      <tr>
        <td>[:digit:]</td>
        <td>مجموعه کاراکترهای عددی</td>
      </tr>
      <tr>
        <td>[:lower:]</td>
        <td>مجموعه حروف کوچک</td>
      </tr>
      <tr>
        <td>[:upper:]</td>
        <td>مجموعه حروف بزرگ</td>
      </tr>
    </tbody>
  </table>
  <p>
    در سیستم‌های لینوکسیِ قدیمی‌تر به‌جای کلاس‌ها از بازه‌های کاراکتری
    (character ranges) استفاده می‌شد که البته هنوز هم در اکثر توزیع‌ها قابل
    استفاده هستند. مثلاً به‌جای [:upper:] می‌توان از بازه کاراکتری [A-Z] استفاده
    کرد.
  </p>
  <p>
    از کاراکترهای wildcard می‌توانیم در هر کامندی که به نام فایل نیاز دارد،
    استفاده کنیم. البته در آینده با کاربردهای بیشتر آنها هم آشنا خواهیم شد.
  </p>
</section>

<section>
  <h2>ایجاد دایرکتوری با کامند mkdir</h2>
  <p>
    کار بررسی کامندهای مربوط به ویرایش فایل و دایرکتوری را با کامند mkdir شروع
    می‌کنیم که از عبارت make directory گرفته شده و مطابق انتظار، برای ایجاد
    دایرکتوری‌ها کاربرد دارد. فرم کلی کامند mkdir به این صورت است:
  </p>
  <pre dir="ltr" data-cm-lang="bash">mkdir directory…</pre>
  <p>
    بنابر قرارداد، وجود سه‌نقطه بعد از نام آرگومان به این معناست که این آرگومان
    می‌تواند تکرار شود. یعنی کامند mkdir می‌تواند یک یا چند دایرکتوری را ایجاد
    کند. کامند زیر یک دایرکتوری با نام test در دایرکتوری جاری ایجاد می‌کند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir test</pre>
  <p>
    اما کامند زیر سه دایرکتوری با نام‌های dir1 و dir2 و dir3 را در دایرکتوری
    جاری ایجاد می‌کند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir dir1 dir2 dir3</pre>
  <p>
    امکان ایجاد دایرکتوری در جایی غیر از دایرکتوری جاری هم وجود دارد. برای مثال،
    کامند زیر یک دایرکتوری با نام demo در دسکتاپ یوزر me ایجاد می‌کند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir /home/me/Desktop/demo</pre>
  <p>
    دقت داشته باشید که وقتی بخواهیم یک دایرکتوری در جایی غیر از دایرکتوری جاری
    ایجاد کنیم، مسیری که به عنوان آرگومان کامند mkdir تعیین می‌کنیم، باید از قبل
    وجود داشته باشد. برای مثال، کامند زیر را در نظر بگیرید:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir /home/me/demo/test</pre>
  <p>
    در اینجا اگر در دایرکتوری home مربوط به یوزر me یک دایرکتوری با نام demo
    وجود داشته باشد، دایرکتوری test درون آن ایجاد می‌شود اما در غیر این صورت،
    خطا گزارش می‌شود. البته اگر کامند بالا را با استفاده از آپشن -p اجرا کنیم،
    اگر دایرکتوری demo وجود نداشته باشد، ساخته می‌شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir -p /home/me/demo/test</pre>
  <p>
    حالا فرض کنید بخواهیم کامندی بنویسیم که دو دایرکتوری با نام‌های dir1 و dir2
    را در محل مشخصی بسازد و همانند مثال قبل ترتیبی بدهیم که اگر مسیر مورد نظر
    وجود ندارد، ساخته شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir -p /home/me/demo/{dir1,dir2}</pre>
  <p>اگر از آکلادها استفاده نکنیم، باید مسیر مورد نظر را دو بار بنویسیم:</p>
  <pre dir="ltr" data-cm-lang="bash">
$ mkdir -p /home/me/demo/dir1 /home/me/demo/dir2</pre
  >
  <p>
    استفاده از آکلادها در کامندهای لینوکس مزایای زیادی دارد که یک نمونه‌اش را
    اینجا دیدیم.
  </p>
</section>

<section>
  <h2>کپی فایل‌ها و دایرکتوری‌ها با کامند cp</h2>
  <p>
    از کامند cp برای کپی فایل‌ها و دایرکتوری‌ها استفاده می‌شود. این کامند
    می‌تواند به یکی از دو فرم کلی زیر باشد:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
cp item1 item2
cp item… directory</pre>
  <p>
    در فرم اول، فایل یا دایرکتوری item1 در فایل یا دایرکتوری item2 کپی می‌شود و
    در فرم دوم، چند فایل یا دایرکتوری در یک دایرکتوری مقصد کپی می‌شود. قبل از
    اینکه مثالی ارائه کنیم، اجازه دهید ابتدا با آپشن‌های مهم کامند cp آشنا شویم.
  </p>

  <h3>آپشن‌های مفید کامند cp</h3>
  <p>
    کامند cp آپشن‌های مهمی دارد که قدرت زیادی به آن می‌دهند. جدول زیر این
    آپشن‌ها را لیست کرده و توضیح کوتاهی راجع به هر یک داده است.
  </p>

  <table>
    <thead>
      <tr>
        <th>آپشن</th>
        <th>کاربرد</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>-a</td>
        <td>
          استفاده از این آپشن باعث می‌شود که با کپی یک فایل، اطلاعات اضافی آن
          فایل نیز در فایل مقصد کپی شود. این اطلاعات اضافی شامل مجوزهای فایل،
          مالکیت فایل، زمان‌های دسترسی و دستکاری و اطلاعات دیگر است. از این آپشن
          زمانی استفاده می‌کنیم که بخواهیم یک کپی دقیق از یک فایل یا دایرکتوری
          ایجاد کنیم که همه‌ی ویژگی‌های فایل یا دایرکتوری اصلی را داشته باشد.
        </td>
      </tr>
      <tr>
        <td>-i</td>
        <td>
          در فرایند کپی، اگر فایل مقصد از قبل وجود داشته باشد، اصطلاحاً بازنویسی
          یا overwrite می‌شود و این کار بدون کسب اجازه از ما انجام می‌شود. اما
          اگر از آپشن -i استفاده کنیم، قبل از بازنویسی از ما تأیید خواسته می‌شود
          و ما می‌توانیم با وارد کردن حرف y اجازه‌ی بازنویسی را صادر کنیم یا با
          وارد کردن حرف n از این کار جلوگیری کنیم.
        </td>
      </tr>
      <tr>
        <td>-r</td>
        <td>
          از این آپشن برای کپی دایرکتوری‌ها به صورت بازگشتی (recursive) استفاده
          می‌شود که شامل کپی همه‌ی زیردایرکتوری‌ها و فایل‌های درون دایرکتوری
          می‌شود.
        </td>
      </tr>
      <tr>
        <td>-u</td>
        <td>
          وقتی فایل‌هایی را از یک دایرکتوری به دایرکتوری دیگر کپی می‌کنیم، فقط
          فایل‌هایی را کپی می‌کند که یا در دایرکتوری مقصد نیستند یا اینکه تغییر
          کرده‌اند. در واقع، این آپشن باعث می‌شود کار اضافی انجام نشود.
        </td>
      </tr>
      <tr>
        <td>-v</td>
        <td>
          اگر از این آپشن استفاده کنیم، اطلاعات و گزارش مختصری در مورد اینکه چه
          آیتم‌هایی کپی شدند، نمایش داده می‌شود.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    حالا با ارائه‌ی چند مثال، نقش کامند cp و آپشن‌های جدول بالا را در عمل
    می‌بینیم. با کامند ساده‌ی زیر شروع می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ cp file1 file2</pre>
  <p>
    در اینجا فایلی داریم با نام file1 که قصد داریم محتوای آن را در یک فایل دیگر
    با نام file2 کپی کنیم. اگر file2 وجود داشته باشد، محتوای file1 در آن کپی شده
    و در واقع، بازنویسی می‌شود. اما اگر file2 وجود نداشته باشد، ساخته شده و
    file1 در آن کپی می‌شود. به هر حال، بعد از اجرای این دستور، فایل‌های file1 و
    file2 محتوای یکسانی خواهند داشت. کامند بعدی را ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ cp -i file1 file2</pre>
  <p>
    این کامند همان کامند قبل است که آپشن -i به آن اضافه شده است. این کار باعث
    می‌شود که اگر file2 موجود باشد، قبل از بازنویسی آن از ما سوال پرسیده شود.
    حالا به کامند بعدی نگاه کنید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ cp file1 file2 dir1</pre>
  <p>
    اجرای این کامند باعث می‌شود که یک نسخه از فایل‌های file1 و file2 در
    دایرکتوری dir1 که باید موجود باشد، کپی شوند. مثال بعدی را ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ Cp dir1/* dir2</pre>
  <p>
    این کامند همه‌ی فایل‌های موجود در دایرکتوری dir1 را در دایرکتوری dir2 که
    باید وجود داشته باشد، کپی می‌کند. اما حالا کامند بعدی را ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ cp -r dir1 dir2</pre>
  <p>
    در اینجا اگر dir2 وجود نداشته باشد، ساخته شده و بعد از کپی، محتوای یکسانی با
    dir2 خواهد داشت. اما اگر dir2 از قبل موجود باشد، دایرکتوری dir1 و محتوایش در
    آن کپی می‌شوند.
  </p>
</section>

<section>
  <h2>انتقال و تغییر نام فایل‌ها با کامند mv</h2>
  <p>
    کامند mv برای انتقال یا تغییر نام فایل‌ها و دایرکتوری‌ها کاربرد دارد. نحوه‌ی
    استفاده از این کامند مشابه کامند cp است و بنابراین، یک‌راست می‌رویم سراغ
    بررسی چند مثال.
  </p>
  <p>
    فرض کنید در دایرکتوری جاری فایلی با نام file1 داشته باشیم. حالا کامند زیر را
    در نظر بگیرید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv file1 file2</pre>
  <p>
    اجرای این کامند در شرایطی که فایل file2 وجود نداشته باشد، باعث تغییر نام
    file1 به file2 می‌شود. اما اگر فایل file2 وجود داشته باشد، بازنویسی شده و
    محتوای file1 را دریافت می‌کند. در هر حال، بعد از اجرای این کامند، فایل file1
    دیگر وجود نخواهد داشت. حالا به کامند زیر نگاه کنید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv file1 /etc/file2</pre>
  <p>
    با اجرای این کامند، اگر فایل file2 در دایرکتوری مقصد (یعنی /etc) وجود نداشته
    باشد، فایل file1 به آن‌جا منتقل می‌شود و اگر فایل file2 در دایرکتوری مقصد
    وجود داشته باشد، با محتوای فایل file1 بازنویسی می‌شود. به مثال بعدی دقت
    کنید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv file1 file2 dir1</pre>
  <p>
    این کامند، دو فایل file1 و file2 را از دایرکتوری جاری به دایرکتوری dir1
    منتقل می‌کند. و اما مثال آخر:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv dir1 dir2</pre>
  <p>
    در اینجا اگر دایرکتوری مقصد یعنی dir2 وجود نداشته باشد، ساخته می‌شود و
    محتوای دایرکتوری مبدأ یعنی dir1 به آن منتقل می‌شود. یعنی در واقع، دایرکتوری
    dir1 به dir2 تغییر نام می‌دهد. اما اگر دایرکتوری مقصد موجود باشد، خود
    دایرکتوری dir1 و محتوایش به dir2 منتقل می‌شوند. دقت داشته باشید که در اینجا
    بر خلاف کامند cp نیازی به استفاده از آپشن -r نیست.
  </p>
  <p>
    آپشن‌های -i و -u و -v برای کامند mv هم قابل استفاده هستند و کاربردشان با
    آنچه در مورد کامند cp دیدیم، یکسان است.
  </p>
</section>

<section>
  <h2>حذف فایل‌ها با کامند rm</h2>
  <p>
    کامند rm برای حذف (remove) فایل‌ها و دایرکتوری‌ها کاربرد دارد. فرم کلی این
    کامند به این صورت است:
  </p>
  <pre dir="ltr" data-cm-lang="bash">rm item…</pre>
  <p>
    برای کامند rm می‌توان از آپشن‌های -i و -v و -r همانند آنچه در مورد کامندهای
    cp و mv دیدیم، استفاده کرد. علاوه بر اینها یک آپشن دیگر با نام -f یا --force
    هم برای این کامند قابل استفاده است که در مثال‌های زیر با نقش آن آشنا خواهیم
    شد. مثال زیر را ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ rm file1</pre>
  <p>
    این ساده‌ترین مثال ممکن از دستور rm است که باعث حذف فایلی به نام file1
    می‌شود. مثال بعدی از آپشن -i استفاده می‌کند.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ rm -i file1</pre>
  <p>
    مطابق انتظار، قبل از حذف file1 از ما اجازه می‌گیرد. حالا مثال بعدی را
    ببینید.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ rm -r file1 dir1</pre>
  <p>
    این کامند باعث حذف فایل file1 و دایرکتوری dir1 و محتوایش می‌شود. مثال زیر
    نقش آپشن -f را نشان می‌دهد.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ rm -rf file1 dir1</pre>
  <p>
    این کامند فقط یک آپشن -f به کامند قبلی اضافه کرده که باعث می‌شود اگر یکی از
    آیتم‌های file1 یا dir1 موجود نباشند، کامند ادامه پیدا کند و بقیه‌ی آیتم‌ها
    حذف شوند.
  </p>

  <div data-callout="warning">
    <strong>هشدار در مورد کامند rm</strong>
    <p>
      هنگام استفاده از کامند rm باید جانب احتیاط را نگه دارید. فایل‌هایی که با
      استفاده از این کامند حذف شوند، دیگر راهی برای بازگرداندن ندارند و به عبارت
      دیگر، حذف فایل‌ها یک فرایند غیرقابل بازگشت است. فرض کنید بخواهیم با
      استفاده از کامند rm *.html همه‌ی فایل‌های HTML موجود در دایرکتوری جاری را
      حذف کنیم. اگر اشتباهاً یک فاصله بین کاراکتر * و .html قرار دهیم، کامند rm
      * .html اجرا می‌شود که به این معناست که همه‌ی فایل‌های موجود و فایل .html
      که طبیعتاً وجود ندارد، حذف شوند و ناگهان با فاجعه مواجه می‌شویم. یک ایده‌ی
      مناسب برای کاهش احتمال رخ دادن چنین اتفاقات ناگواری این است که هر کامند rm
      را ابتدا با ls تست کنیم و مطمئن شویم همان فایل‌هایی لیست می‌شوند که
      می‌خواهیم حذفشان کنیم و سپس، کلید جهت بالا را بزنیم تا کامند ls را ببینیم
      و عبارت ls را در آن با rm جایگزین کنیم. این توصیه را جدی بگیرید.
    </p>
  </div>
</section>

<section>
  <h2>ایجاد لینک با کامند ln</h2>
  <p>
    در درس قبل در مورد لینک‌ها و کاربرد آنها صحبت کردیم و معرفی کامند مربوط به
    ایجاد لینک‌ها را به این درس موکول کردیم. برای ایجاد لینک از کامند ln استفاده
    می‌شود. از این کامند به صورت زیر استفاده می‌شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ ln file link</pre>
  <p>
    در اینجا file نام فایلی است که قصد داریم به آن لینک بدهیم و link نامی است که
    برای لینک در نظر می‌گیریم. لینک‌هایی که به این روش ایجاد می‌شوند، از نوع
    hard هستند که با دو محدودیت همراه هستند:
  </p>
  <ul class="list-disc pr-6">
    <li>
      فقط برای فایل‌های معمولی قابل استفاده‌اند و امکان ایجاد یک لینک hard به یک
      دایرکتوری وجود ندارد.
    </li>
    <li>
      محدود به پارتیشن هستند؛ یعنی نمی‌توان یک لینک hard به فایلی که در یک
      پارتیشن دیگر قرار دارد، ایجاد کرد.
    </li>
  </ul>
  <p>
    لینک‌های soft که symbolic link یا symlink هم نامیده می‌شوند، با هدف غلبه بر
    دو محدودیت فوق در سیستم‌های لینوکسی جدیدتر معرفی شدند. برای ایجاد یک لینک از
    نوع soft باید از آپشن -s استفاده کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ ln -s file link</pre>
  <p>
    بر خلاف لینک‌های hard که از فایل اصلی قابل تمایز نیستند، یک لینک soft بیشتر
    شبیه یک shortcut در ویندوز است. اگر لینک را حذف کنیم، برای فایل اتفاقی
    نمی‌افتد اما اگر فایل حذف شود، لینک حذف نمی‌شود اما معتبر نیست و اصطلاحاً
    broken است.
  </p>
</section>

<section>
  <h2>آزمایش کامندها</h2>
  <p>
    با کامندهای مربوط به ویرایش فایل‌ها و دایرکتوری‌ها در لینوکس آشنا شدیم و
    مهمترین آپشن‌های هر یک را معرفی کردیم. حالا قصد داریم با آزمایش این کامندها
    و آپشن‌ها در محیط واقعی، مهارت کار با آنها را تقویت کنیم. کار را با کامند
    mkdir و ایجاد دایرکتوری‌ها شروع می‌کنیم.
  </p>

  <h3>ایجاد دایرکتوری</h3>
  <p>
    گفتیم که برای ایجاد دایرکتوری‌ها از کامند mkdir استفاده می‌شود. قصد داریم
    ابتدا یک دایرکتوری با نام playground درون دایرکتوری home خود بسازیم و
    آزمایشات خود را درون آن انجام دهیم. اول با یک کامند cd بدون هیچ آرگومانی
    مطمئن می‌شویم که در دایرکتوری home خودمان قرار داریم و سپس، از یک کامند
    mkdir برای ساخت دایرکتوری playground استفاده می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cd
$ mkdir playground</pre>
  <p>به جای دو دستور بالا می‌توانستیم از تک‌دستور زیر هم استفاده کنیم:</p>
  <pre dir="ltr" data-cm-lang="bash">$ mkdir /home/me/playground</pre>
  <p>
    که البته شما باید به جای me نام کاربری اکانت خودتان را وارد کنید. در اینجا
    از یک آدرس مطلق استفاده کرده‌ایم و بنابراین، می‌توانیم مطمئن باشیم فارغ از
    اینکه در کجای Filesystem قرار داریم، دایرکتوری playground در دایرکتوری home
    ساخته می‌شود.
  </p>
  <p>
    حالا با استفاده از دستورات زیر، دو دایرکتوری با نام‌های dir1 و dir2 درون
    دایرکتوری playground ایجاد می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cd playground
$ mkdir dir1 dir2</pre
  >

  <h3>کپی فایل‌ها و دایرکتوری‌ها</h3>
  <p>
    حالا ما در دایرکتوری playground قرار داریم و قصد داریم فایل /etc/passwd را
    در دایرکتوری جاری کپی کنیم. این کار با استفاده از کامند زیر قابل انجام است:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ cp /etc/passwd .</pre>
  <p>حالا اگر کامند ls را اجرا کنیم، باید نتیجه‌ی زیر را مشاهده کنیم:</p>

  <pre dir="ltr" data-cm-lang="bash">
$ ls -l
total 12
drwxrwxr-x 2 me me 4096 2024-07-10 16:40 dir1
drwxrwxr-x 2 me me 4096 2024-07-10 16:40 dir2
-rw-r--r-- 1 me me 1650 2024-07-10 16:07 passwd</pre
  >
  <p>
    یک بار دیگر دستور کپی قبل را اجرا می‌کنیم، منتها این بار آپشن -v را به کامند
    اضافه می‌کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cp -v /etc/passwd . 
`/etc/passwd' -> `./passwd'</pre
  >
  <p>
    همانطور که می‌بینید، این بار توضیح مختصری راجع به عملیات کپی انجام‌شده در
    خروجی نمایش داده شده است. از طرفی، با وجودی که فایل passwd به خاطر اجرای
    کامند کپی قبلی، الان در دایرکتوری playground وجود دارد، اما دستور کپی این
    کار را تکرار می‌کند و بدون سر و صدا فایل passwd را بازنویسی می‌کند. اما اگر
    مثل کامند زیر از آپشن -i استفاده کنیم، قبل از بازنویسی از ما اجازه می‌گیرد:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cp -i /etc/passwd .
cp: overwrite './passwd'?</pre
  >
  <p>
    فشردن کلید y باعث تأیید عملیات بازنویسی و هر کلید دیگر (از جمله n) باعث لغو
    عملیات می‌شود.
  </p>

  <h3>انتقال و تغییر نام فایل‌ها</h3>
  <p>
    در ادامه، با استفاده از کامند زیر، نام فایل passwd را به fun تغییر می‌دهیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv passwd fun</pre>
  <p>
    حالا با استفاده از کامند زیر، فایل fun را به دایرکتوری dir1 منتقل می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv fun dir1</pre>
  <p>
    الان فایل fun در دایرکتوری dir1 قرار دارد و می‌خواهیم آن را به dir2 منتقل
    کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv dir1/fun dir2</pre>
  <p>
    در نهایت، با استفاده از کامند زیر این فایل را به دایرکتوری جاری
    برمی‌گردانیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv dir2/fun .</pre>
  <p>
    حالا اجازه دهید تأثیر کامند mv را روی دایرکتوری‌ها ببینیم. ابتدا یک بار دیگر
    فایل fun را به دایرکتوری dir1 منتقل می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">$ mv fun dir1</pre>
  <p>
    سپس دایرکتوری dir1 را به دایرکتوری dir2 منتقل می‌کنیم و نتیجه را با کامند ls
    تأیید می‌کنیم:
  </p>

  <pre dir="ltr" data-cm-lang="bash">
$ mv dir1 dir2 
$ ls -l dir2 
total 4
drwxrwxr-x 2 me me 4096 2024-07-11 06:06 dir1 
$ ls -l dir2/dir1 
total 4
-rw-r--r-- 1 me me 1650 2024-07-10 16:33 fun</pre
  >
  <p>
    با توجه به موجود بودن dir2 کامند mv باعث شد که dir1 به dir2 منتقل شود. اگر
    dir2 وجود نداشت، کامند mv باعث تغییر نام dir1 به dir2 می‌شد.
  </p>
  <p>در نهایت، با کامندهای زیر همه‌چیز را به حالت قبل برمی‌گردانیم:</p>
  <pre dir="ltr" data-cm-lang="bash">
$ mv dir2/dir1 .
$ mv dir1/fun .</pre>

  <h3>ایجاد لینک‌های Hard</h3>
  <p>
    نوبت به کامند ln و ایجاد لینک می‌رسد. ابتدا چند لینک از نوع hard به فایل fun
    ایجاد می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ln fun fun-hard
$ ln fun dir1/fun-hard
$ ln fun dir2/fun-hard</pre
  >
  <p>
    با این حساب، ما لان ۴ نسخه از این فایل را داریم. کامند ls را برای مشاهده‌ی
    محتوای دایرکتوری playground به کار می‌گیریم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l
total 16
drwxrwxr-x 2 me me 4096 2024-07-14 16:17 dir1
drwxrwxr-x 2 me me 4096 2024-07-14 16:17 dir2
-rw-r--r-- 4 me me 1650 2024-01-07 16:33 fun
-rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun-hard</pre
  >
  <p>
    همانطور که می‌بینید، فیلد دوم برای هر دو آیتم fun و fun-hard برابر با 4 است
    که به تعداد لینک‌های hard اشاره می‌کند. برای اینکه ببینیم این فایل‌ها در
    واقع یکی هستند، کامند ls را به صورت زیر اجرا می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -li
total 16
12353539 drwxrwxr-x 2 me me 4096 2024-07-14 16:17 dir1
12353540 drwxrwxr-x 2 me me 4096 2024-07-14 16:17 dir2
12353538 -rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun
12353538 -rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun-hard</pre
  >
  <p>
    در اینجا آپشن -i باعث نمایش یک فیلد اضافی شده که به یک ساختار داده به نام
    inode اشاره می‌کند. فعلاً کاری به جزئیات مربوط به inode نداریم اما یکسان
    بودن مقدار این فیلد برای دو فایل بالا نشان می‌دهد که این فایل‌ها یکی هستند.
  </p>

  <h3>ایجاد لینک‌های Soft</h3>
  <p>
    لینک‌های soft نوع خاصی از فایل‌ها هستند که دارای یک اشاره‌گر متنی به فایل یا
    دایرکتوری هدف هستند. ایجاد یک لینک soft مشابه لینک‌های hard ولی با استفاده
    از آپشن -s انجام می‌شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ln -s fun fun-sym
$ ln -s ../fun dir1/fun-sym
$ ln -s ../fun dir2/fun-sym</pre
  >
  <p>
    کامند اول کاملاً سرراست و فاقد ابهام است. ما با اضافه کردن آپشن -s به دستور
    ln یک لینک soft ایجاد کرده‌ایم. اما دو کامند بعدی چطور؟ وقتی ما یک لینک soft
    ایجاد می‌کنیم، در واقع در حال فراهم کردن یک توصیف متنی از محل فایل هدف نسبت
    به لینک هستیم. به خروجی کامند ls زیر نگاه کنید:
  </p>

  <pre dir="ltr" data-cm-lang="bash">
$ ls -l dir1
total 4
-rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun-hard
lrwxrwxrwx 1 me me 6 2024-07-15 15:17 fun-sym -> ../fun</pre
  >
  <p>
    مثال زیر نشان می‌دهد که لینک‌های soft می‌توانند به دایرکتوری هم اشاره کنند:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ln -s dir1 dir1-sym
$ ls -l
total 16
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2024-07-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir2
-rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun
-rw-r--r-- 4 me me 1650 2024-07-10 16:33 fun-hard
lrwxrwxrwx 1 me me 3 2024-07-15 15:15 fun-sym -> fun</pre
  >

  <h3>حذف فایل‌ها و دایرکتوری‌ها</h3>
  <p>
    یادآوری می‌کنم که کامند rm برای حذف فایل‌ها و دایرکتوری‌ها کاربرد دارد. در
    این بخش با استفاده از این کامند، دایرکتوری‌ها و فایل‌هایی را که ایجاد کردیم،
    حذف می‌کنیم. این کار را با حذف یکی از لینک‌های hard شروع می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ rm fun-hard
$ ls -l
total 12
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2024-07-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir2
-rw-r--r-- 3 me me 1650 2024-07-10 16:33 fun
lrwxrwxrwx 1 me me 3 2024-07-15 15:15 fun-sym -> fun</pre
  >
  <p>
    همانطور که انتظار داشتیم، فایل fun-hard حذف شده و تعداد لینک‌ها از ۴ به ۳
    کاهش پیدا کرده است. در ادامه، فایل fun را حذف می‌کنیم و آپشن -i را هم تست
    می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ rm -i fun
rm: remove regular file 'fun'?</pre
  >
  <p>
    کاراکتر y را وارد می‌کنیم تا فایل حذف شود. اما حالا اجازه دهید یک بار دیگر
    خروجی کامند ls را ببینیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls -l
total 8
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2024-07-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir2
lrwxrwxrwx 1 me me 3 2024-07-15 15:15 fun-sym -> fun</pre>
  <p>
    با توجه به حذف فایل fun لینک fun-sym حالا دیگر یک لینک broken و غیر قابل
    استفاده است. این لینک و لینک dir1-sym را حذف می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ rm fun-sym dir1-sym
$ ls -l
total 8
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir1
drwxrwxr-x 2 me me 4096 2024-07-15 15:17 dir2</pre>
  <p>
    نکته‌ای که باید در مورد لینک‌های soft به خاطر بسپارید این است که اغلب اعمال
    روی فایل هدف انجام می‌شوند نه روی لینک اما کامند rm یک استثناست که وقتی روی
    لینک اعمال شود، خود لینک را حذف می‌کند نه فایل هدف را.
  </p>
  <p>
    و در نهایت، دایرکتوری playground را حذف می‌کنیم. برای این کار، با کامند cd
    به دایرکتوری home برمی‌گردیم و با کامند rm و یک آپشن -r این دایرکتوری و
    محتوایش را حذف می‌کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ cd
$ rm -r playground</pre>
</section>
