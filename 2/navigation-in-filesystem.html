<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    حالا که با نحوه‌ی جابجایی در درخت Filesystem آشنا شدیم، قصد داریم نگاهی
    داشته باشیم به بخش‌های مختلف سیستم لینوکسی خودمان. منتها لازمه‌ی این سفر
    هیجان‌انگیز این است که اولاً کمی بیشتر با کامند <bdi>ls</bdi> آشنا شویم و ثانیاً
    دو کامند دیگر با نام‌های <bdi>file</bdi> و <bdi>less</bdi> را هم دریابیم که اولی نوع
    فایل‌ها را مشخص می‌کند و دومی محتوای فایل‌ها را نمایش می‌دهد. پس از معرفی و
    بررسی این دو کامند، نگاهی خواهیم داشت به مهمترین دایرکتوری‌های filesystem
    لینوکس و با نقش هر یک آشنا می‌شویم.
  </p>
</section>

<section>
  <h2>بررسی دقیق‌تر کامند <bdi>ls</bdi></h2>
  <p>
    کامند <bdi>ls</bdi> شاید پرکاربردترین کامندی باشد که در توزیع‌های لینوکسی وجود
    دارد. همانطور که قبلاً دیدیم، این کامند محتوای دایرکتوری‌ها را لیست می‌کند و
    همانطور که در این درس خواهیم دید، با استفاده از آرگومان‌ها و آپشن‌های متعددی
    که برای این کامند وجود دارد، می‌توانیم اطلاعات مهمی را در مورد فایل‌ها و
    دایرکتوری‌های لیست‌شده دریافت کنیم.
  </p>
  <p>
    اجرای کامند <bdi>ls</bdi> به صورت خشک و خالی (یعنی بدون هیچ آرگومان و آپشن) باعث
    می‌شود که محتوای دایرکتوری جاری نمایش داده شود.
  </p>
  <pre dir="ltr" data-cm-lang="bash"><strong>$ ls</strong>
Desktop Documents Music Pictures Public Templates Videos</pre>
  <p>
    در مثال بالا، کامند <bdi>ls</bdi> را در حالی اجرا کرده‌ایم که در دایرکتوری home
    خود قرار داشتیم و در نتیجه، نام فایل‌ها و دایرکتوری‌های موجود در این
    دایرکتوری (که البته همگی از نوع دایرکتوری هستند) نمایش داده شده است. اما اگر
    بخواهیم محتوای یک دایرکتوری دیگر غیر از دایرکتوری جاری را ببینیم، کافیست
    مانند مثال زیر آدرس دایرکتوری مورد نظر را به عنوان آرگومان کامند
    <bdi>ls</bdi> وارد کنیم:
  </p>
  <pre dir="ltr" data-cm-lang="bash"><strong>$ ls /usr</strong>
bin games include lib local sbin share src</pre>
  <p>
    به علاوه، می‌توانیم با استفاده از یک آپشن -l کاری کنیم که فرمت
    خروجی تغییر کند و اطلاعات بیشتری در مورد محتوای دایرکتوری نمایش داده شود:
  </p>
  <pre dir="ltr" data-cm-lang="bash"><strong>$ ls -l</strong>
total 56
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Desktop
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Documents
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Music
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Pictures
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Public
drwxrwxr-x 2 me me 4096 2024-10-26 17:20 Templates
drwxrwxr-x 2 me me 4096 2024-10-26 17:20 Videos</pre>
  <p>
    در واقع، با اضافه‌کردن آپشن -l از کامند <bdi>ls</bdi> می‌خواهیم که
    محتوا را در فرمت <b>Long</b> نمایش دهد. در این فرمت، هر خط شامل اطلاعات
    مربوط به یک فایل یا دایرکتوری است که با چند و چون این اطلاعات در ادامه آشنا
    خواهیم شد.
  </p>

  <div data-callout="info">
    <strong>در لینوکس هر چیزی فایل است</strong>
    <p>
      این جمله یک مفهوم اساسی و کلیدی و بخشی از فلسفه‌ی لینوکس محسوب می‌شود که
      هرچه بیشتر در دنیای لینوکس به سر ببرید، آن را به شکل عمیق‌تری درک خواهید
      کرد. به بیان ساده، این جمله به این معناست که در لینوکس هر چیزی از فایل‌های
      متنی و تصاویر گرفته تا دستگاه‌های سخت‌افزاری و حتی پراسس‌ها (برنامه‌های در
      حال اجرا) در سیستم‌عامل به صورت فایل نمایش داده می‌شوند. دایرکتوری‌ها هم
      نوعی فایل هستند که برای سازماندهی فایل‌های دیگر استفاده می‌شوند. یکپارچگی
      و انسجام Filesystem، انعطاف‌پذیری و تسهیل فرایند اتوماسیون مزایایی هستند
      که به‌واسطه‌ی پیاده‌سازی این فلسفه در لینوکس حاصل شده‌اند. ابزارهای خط
      فرمان قدرتمندی که برای مدیریت فایل‌ها طراحی شده‌اند، در واقع می‌توانند هر
      چیزی را مدیریت کنند. چرا؟ چون در لینوکس هر چیزی یک فایل است.
    </p>
  </div>
</section>
<h3>آرگومان‌ها و آپشن‌ها</h3>
<p>
  اکثر کامندها دارای یک یا چند آرگومان و چند سوئیچ یا آپشن (option) هستند که
  حالت‌های مختلفی را برای یک کامند ایجاد می‌کنند. مثلاً دیدیم که کامند
  <bdi>ls</bdi> وقتی به همراه آپشن -l به کار گرفته شود، خروجی را در فرمت
  Long نمایش می‌دهد یا کامند <bdi>cd</bdi> وقتی یک مسیر را به عنوان آرگومان دریافت
  کند، از دایرکتوری جاری به آن مسیر منتقل می‌شود. در واقع، فرم کلی یک کامند
  لینوکسی به این صورت است:
</p>
<pre dir="ltr" data-cm-lang="bash">$ command -options arguments</pre>
<p>یک آپشن می‌تواند دارای یکی از فرم‌های زیر باشد:</p>
<ul class="list-disc pr-6">
  <li>
    فرمت کوتاه یا short format که در آن آپشن به صورت یک حرف بعد از کاراکتر خط
    تیره (dash) می‌آید. مثل <bdi>ls</bdi> -l
  </li>
  <li>
    فرمت طولانی یا long format که در آن آپشن به صورت یک کلمه بعد از دو کاراکتر
    خط تیره می‌آید. مثل ls --reverse
  </li>
</ul>
<p>
  فرمت long ریشه در پروژه‌ی GNU دارد و اکثر کامندهایی که از این فرمت پشتیبانی
  می‌کنند، متعلق به پروژه‌ی GNU هستند. در این فرمت، اگر نام یک آپشن بیش از یک
  کلمه باشد به صورت --word1-word2 خواهد بود. به‌علاوه، در مورد فرمت
  short، اکثر کامندها اجازه می‌دهند که چند آپشن پشت سر هم بیایند. مثلاً‌ به‌جای
  ls -l -a می‌توان از ls -la استفاده کرد.
</p>
<div data-callout="info">
  <p>
    توجه داشته باشید که نام آپشن‌ها مانند نام فایل‌ها در لینوکس نسبت به بزرگی و
    کوچکی حروف حساس یا اصطلاحاً case sensitive است.
  </p>
</div>
<p>
  خوب، برگردیم سراغ کامند <bdi>ls</bdi> و تعدادی از مهمترین و پرکاربردترین آپشن‌های
  این کامند را ببینیم. جدول زیر این آپشن‌ها را در دو فرم short و long لیست کرده
  و توضیح مختصری راجع به هر یک آورده است.
</p>
<table>
  <tbody>
    <tr>
      <th>آپشن short</th>
      <th>آپشن long</th>
      <th>توضیح</th>
    </tr>
    <tr>
      <td>-a</td>
      <td>--all</td>
      <td>
        همه‌ی فایل‌ها را لیست می‌کند، از جمله فایل‌های مخفی که نامشان با یک
        کاراکتر نقطه (period) شروع می‌شود و در حالت عادی لیست نمی‌شوند.
      </td>
    </tr>
    <tr>
      <td>-A</td>
      <td>--almost-all</td>
      <td>
        مانند آپشن -a عمل می‌کند با این تفاوت که دایرکتوری‌های . و ..
        را لیست نمی‌کند.
      </td>
    </tr>
    <tr>
      <td>-d</td>
      <td>--directory</td>
      <td>
        استفاده از این آپشن به همراه -l باعث می‌شود که به‌جای لیست
        کردن محتویات یک دایرکتوری، جزئیاتی در مورد خود دایرکتوری ارائه شود.
      </td>
    </tr>
    <tr>
      <td>-F</td>
      <td>--classify</td>
      <td>
        این آپشن یک کاراکتر به انتهای فایل‌های لیست‌شده اضافه می‌کند که نوع آن
        فایل را نشان می‌دهد. برای مثال، به دایرکتوری‌ها یک کاراکتر / اضافه
        می‌کند یا به فایل‌های اجرایی یک کاراکتر * اضافه می‌کند.
      </td>
    </tr>
    <tr>
      <td>-h</td>
      <td>--human-readable</td>
      <td>
        استفاده از این آپشن باعث می‌شود که در فرمت Long سایز آیتم‌ها به‌جای بایت
        بر حسب فرمت‌های مناسب‌تری نمایش داده شود.
      </td>
    </tr>
    <tr>
      <td>-l</td>
      <td></td>
      <td>نتایج را در فرمت Long نمایش می‌دهد.</td>
    </tr>
    <tr>
      <td>-r</td>
      <td>--reverse</td>
      <td>
        ترتیب نمایش آیتم‌ها را که در حالت پیش‌فرض صعودی است، معکوس می‌کند.
      </td>
    </tr>
    <tr>
      <td>-S</td>
      <td></td>
      <td>ترتیب نمایش آیتم‌ها را از روی سایز آنها تعیین می‌کند.</td>
    </tr>
    <tr>
      <td>-t</td>
      <td></td>
      <td>ترتیب نمایش آیتم‌ها را از روی زمان ویرایش آنها تعیین می‌کند.</td>
    </tr>
  </tbody>
</table>

<h3>نگاهی دقیق‌تر به فرمت Long</h3>
<p>
  گفتیم و دیدیم که آپشن -l باعث می‌شود که خروجی دستور <bdi>ls</bdi> در
  فرمت Long نمایش داده شود که با ارائه‌ی جزئیات و اطلاعات زیادی در مورد آیتم‌های
  لیست‌شده همراه است. یک بار دیگر به خروجی کامند <bdi>ls</bdi> -l در دایرکتوری home
  یک یوزر با نام me نگاه کنید:
</p>
<pre dir="ltr" data-cm-lang="bash"><strong>$ ls -l</strong>
total 56
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Desktop
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Documents
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Music
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Pictures
drwxrwxr-x 2 me me 4096 2024-07-26 17:20 Public
drwxrwxr-x 2 me me 4096 2024-10-26 17:20 Templates
drwxrwxr-x 2 me me 4096 2024-10-26 17:20 Videos</pre>

<p>
  هر سطر اطلاعات مربوط به یک فایل را نشان می‌دهد. در اینجا همه‌ی فایل‌ها از نوع
  دایرکتوری هستند. جدول زیر توضیح می‌دهد که اطلاعات سطر اول چه معنایی دارند.
</p>

<table>
  <tbody>
    <tr>
      <th>فیلد</th>
      <th>معنی</th>
    </tr>
    <tr>
      <td>drwxrwxr-x</td>
      <td>
        این رشته از ۱۰ کاراکتر تشکیل شده که اولی نشان‌دهنده‌ی نوع فایل است. در
        مورد دایرکتوری‌ها حرف d و در مورد فایل‌های معمولی یک کاراکتر خط تیره به
        عنوان اولین کاراکتر این رشته دیده می‌شود. ۹ کاراکتر بعدی را باید در قالب
        سه گروه سه‌تایی ببینیم که مجوز دسترسی به فایل را به‌ترتیب، برای یوزر
        مالک فایل، اعضای گروه مالک فایل و سایر افراد نمایش می‌دهند. برای درک
        جزئیات مربوط به این رشته باید تا فصل نهم صبر کنید.
      </td>
    </tr>
    <tr>
      <td>2</td>
      <td>
        تعداد لینک‌های Hard مربوط به فایل را نمایش می‌دهد. در بخش پایانی همین
        درس با لینک‌های Hard و Soft آشنا خواهیم شد.
      </td>
    </tr>
    <tr>
      <td>me</td>
      <td>نام کاربری مالک فایل</td>
    </tr>
    <tr>
      <td>me</td>
      <td>نام گروه مالک فایل</td>
    </tr>
    <tr>
      <td>4096</td>
      <td>سایز آیتم بر اساس بایت</td>
    </tr>
    <tr>
      <td>2024-07-29-17:20</td>
      <td>تاریخ و زمان آخرین دستکاری فایل</td>
    </tr>
    <tr>
      <td>Desktop</td>
      <td>نام فایل</td>
    </tr>
  </tbody>
</table>
<section>
  <h2>تعیین نوع فایل با کامند <bdi>file</bdi></h2>
  <p>
    همانطور که قبلاً هم گفتیم، در لینوکس نام یک فایل لزوماً نشان‌دهنده‌ی محتوای
    آن نیست. برای اطلاع از نوع محتوای یک فایل، از کامندی به نام
    <bdi>file</bdi> استفاده می‌کنیم. این کامند دارای فرم کلی
    <bdi>file</bdi> filename است که اطلاعاتی را در مورد نوع فایل filename در خروجی
    نمایش می‌دهد.
  </p>
  <pre dir="ltr" data-cm-lang="bash"><strong>$ file picture.jpeg</strong>
picture.jpg: JPEG image data, JFIF standard 1.01
<strong>$ file /etc/passwd</strong>
/etc/passwd: ASCII text</pre>
  <p>
    در مثال بالا، خروجی کامند <bdi>file</bdi> را برای یک فایل تصویری و یک فایل متنی
    می‌بینید.
  </p>
</section>

<section>
  <h2>مشاهده محتوای فایل با کامند <bdi>less</bdi></h2>
  <p>
    کامند <bdi>less</bdi> برنامه‌ای است برای مشاهده‌ی محتوای فایل‌های متنی. در
    لینوکس خیلی از فایل‌ها از نوع فایل‌های متنی هستند و <bdi>less</bdi> محتوای این
    فایل‌ها را به شکلی مناسب نمایش می‌دهد. در سیستم‌های لینوکسی ابزارهای
    قدرتمندی هم برای ویرایش فایل‌های متنی وجود دارد که فعلاً موضوع بحث ما
    نیستند. الان فقط می‌خواهیم در مورد مشاهده‌ی محتوای فایل‌های متنی صحبت کنیم؛
    یعنی همان کاری که کامند <bdi>less</bdi> انجام می‌دهد. فرم کلی کامند
    <bdi>less</bdi> به صورت زیر است:
  </p>
  <pre dir="ltr" data-cm-lang="bash"><strong>$ less fiename</strong></pre>
  <p>
    پس، کافیست آدرس فایل مورد نظر را به عنوان آرگومان کامند <bdi>less</bdi> وارد
    کنیم. <bdi>less</bdi> در واقع، یک ابزار <b>Pager</b> است؛ چنین ابزارهایی امکان
    جابجایی بین صفحات را در فایل‌های متنی که بیش از یک صفحه هستند، فراهم
    می‌کنند. جدول زیر چند کامند کیبورد را لیست کرده که در برنامه‌ی
    <bdi>less</bdi> قابل استفاده هستند.
  </p>
  <table>
    <tbody>
      <tr>
        <th>کامند کیبورد</th>
        <th>کاربرد</th>
      </tr>
      <tr>
        <td>b</td>
        <td>اسکرول به صفحه‌ی قبل</td>
      </tr>
      <tr>
        <td>space</td>
        <td>اسکرول به صفحه‌ی بعد</td>
      </tr>
      <tr>
        <td>↑</td>
        <td>اسکرول به خط قبل</td>
      </tr>
      <tr>
        <td>↓</td>
        <td>اسکرول به خط بعد</td>
      </tr>
      <tr>
        <td>G</td>
        <td>انتقال به انتهای فایل</td>
      </tr>
      <tr>
        <td>g</td>
        <td>انتقال به ابتدای فایل</td>
      </tr>
      <tr>
        <td>/characters</td>
        <td>
          جستجوی رو به جلو برای عبارت characters. منظور از جستجوی رو به جلو این
          است که کل فایل جسجتجو نمی‌شود، بلکه از جایی که هستیم تا انتهای فایل
          ملاک جستجو خواهد بود.
        </td>
      </tr>
      <tr>
        <td>n</td>
        <td>
          اگر عبارت جستجو شده در کامند قبل بیش از یک بار در متن آمده باشد، با
          فشردن کلید n می‌توان به مورد بعدی منتقل شد.
        </td>
      </tr>
      <tr>
        <td>h</td>
        <td>نمایش صفحه‌ی help</td>
      </tr>
      <tr>
        <td>q</td>
        <td>خروج از <bdi>less</bdi></td>
      </tr>
    </tbody>
  </table>
  <div data-callout="info">
    <strong>Less Is More</strong>
    <p>
      این یک شعار در طراحی و معماری مدرن است. ارتباطش با بحث ما این است که ابزار
      <bdi>less</bdi> یک نسخه‌ی توسعه‌یافته از یک ابزار Pager قدیمی‌تر با نام <bdi>more</bdi> است که
      بخشی از پروژه‌ی GNU بود. بر خلاف <bdi>less</bdi> که امکان حرکت رو به جلو و عقب بین
      صفحات را می‌دهد، ابزار <bdi>more</bdi> تنها قادر به حرکت رو به جلو بود.
    </p>
  </div>
</section>
<section>
  <h2>مهمترین دایرکتوری‌های لینوکس</h2>
  <p>
    بسیار خوب، ما حالا ابزار لازم برای سفر در سیستم لینوکسی خودمان را داریم و
    می‌توانیم به بخش‌های مختلف آن سر بزنیم. این تور لینوکس‌گردی دو مزیت برای ما
    دارد: یکی اینکه با مهمترین دایرکتوری‌های Filesystem آشنا می‌شویم و دیگری
    اینکه کامندهای معرفی‌شده را تمرین می‌کنیم. البته من در این سفر همراه شما
    نخواهم بود. توضیحات لازم را در خصوص مکان‌هایی که باید ببینید، در قالب یک
    جدول به شما خواهم داد و شما را تنها می‌گذارم. جسور باشید و در دنیای لینوکس
    کاوش کنید و نگران چیزی نباشید. در لینوکس رازی وجود ندارد و این معنای واقعی
    آزادی در این سیستم عامل است.
  </p>
  <p>
    طراحی Filesystem در لینوکس مشابه با سایر سیستم‌های Unix-like است. علت این
    شباهت این است که استانداردی وجود دارد به نام Filesystem Hierarchy Standard
    یا FHS که همه‌ی توزیع‌های لینوکسی آن را تقریباً به طور کامل پیاده‌سازی
    کرده‌اند. جدول زیر مهمترین دایرکتوری‌هایی را که استاندارد FHS معرفی کرده به
    همراه توضیحی از نقش هر دایرکتوری آورده است. ممکن است بسته به توزیعی که از آن
    استفاده می‌کنید، به تفاوت‌هایی بربخورید که چیز مهمی نیست.
  </p>
  <table>
    <tbody>
      <tr>
        <th>نام دایرکتوری</th>
        <th>نقش دایرکتوری</th>
      </tr>
      <tr>
        <td>/</td>
        <td>دایرکتوری root که ریشه‌ی درخت یا نقطه‌ی شروع Filesystem است.</td>
      </tr>
      <tr>
        <td>/bin</td>
        <td>شامل فایل‌های باینری (برنامه‌های اجرایی) است.</td>
      </tr>
      <tr>
        <td>/boot</td>
        <td>شامل کرنل لینوکس و boot loader است.</td>
      </tr>
      <tr>
        <td>/dev</td>
        <td>
          این دایرکتوری جایی است که کرنل یک لیست از همه‌ی دستگاه‌هایی که
          می‌شناسد را به صورت فایل نگه می‌دارد.
        </td>
      </tr>
      <tr>
        <td>/etc</td>
        <td>
          شامل همه‌ی فایل‌های کانفیگ سیستمی است و علاوه بر آن، چندین اسکریپت را
          نگه می‌دارد که سرویس‌های سیستمی را در زمان بوت راه‌اندازی می‌کنند.
          اینجا فایل‌های مهم زیادی وجود دارد که یکی از آنها فایل
          /etc/passwd است که شامل اطلاعات اکانت‌های کاربری است.
        </td>
      </tr>
      <tr>
        <td>/home</td>
        <td>
          در پیکربندی نرمال، به هر یوزر یک دایرکتوری در /home اختصاص
          داده می‌شود که دایرکتوری home آن یوزر گفته می‌شود و هم‌نام با نام یوزر
          است. مثلاً دایرکتوری home برای یوزری به نام me دایرکتوری
          /home/me است. یک یوزر معمولی فقط در دایرکتوری home خود قادر
          به انجام عملیات نوشتن (write operation) است.
        </td>
      </tr>
      <tr>
        <td>/lib</td>
        <td>
          شامل فایل‌های کتابخانه‌ای اشتراکی است که توسط برنامه‌های سیستمی
          استفاده می‌شوند. این فایل‌ها مشابه فایل‌های .dll در ویندوز
          هستند.
        </td>
      </tr>
      <tr>
        <td>/lost+found</td>
        <td>
          هر دستگاه یا پارتیشن فرمت‌شده که از یک Filesystem مثل ext4 استفاده
          می‌کند، دارای این دایرکتوری است. این دایرکتوری در صورت نیاز به ریکاوری
          ناشی از خرابی بخشی از Filesystem استفاده می‌شود و جز در مواردی که
          اتفاق بدی برای سیستمتان افتاده باشد، خالی است.
        </td>
      </tr>
      <tr>
        <td>/media</td>
        <td>
          در سیستم‌های لینوکسی مدرن، این دایرکتوری حاوی نقاط اتصال (mount
          points) برای دستگاه‌های جداشدنی (Removable) مانند فلش‌های USB یا
          CD-ROM است که به صورت خودکار هنگام اتصال نصب می‌شوند.
        </td>
      </tr>
      <tr>
        <td>/mnt</td>
        <td>
          در سیستم‌های لینوکسی قدیمی‌تر، دستگاه‌های Removable به طور خودکار
          mount نمی‌شدند، بلکه باید آنها را به صورت دستی به دایرکتوری
          /mnt متصل یا mount می‌کردیم.
        </td>
      </tr>
      <tr>
        <td>/opt</td>
        <td>
          این دایرکتوری به عنوان یک مخزن برای نرم‌افزارهای اضافی و اختیاری
          (optional) که بخشی از سیستم‌عامل نیستند، در نظر گرفته شده است. مثلاً
          اگر ویرایشگر <bdi>vim</bdi> را نصب کنید، معمولاً فایل‌های نرم‌افزار در دایرکتوری
          /opt/vim نصب می‌شوند.
        </td>
      </tr>
      <tr>
        <td>/proc</td>
        <td>
          هر پراسس در حال اجرا یک دایرکتوری جداگانه در /proc دارد که
          شامل اطلاعاتی مانند وضعیت پراسس، منابعی که مصرف می‌کند و موارد دیگر
          است. محتوای دایرکتوری /proc نه در دیسک بلکه در RAM ذخیره
          می‌شود، چون محتوای این دایرکتوری به صورت دینامیک تعیین می‌شود و با
          تغییر پراسس‌های در حال اجرا تغییر می‌کند. از این‌رو، این دایرکتوری یک
          دایرکتوری مجازی محسوب می‌شود و عملاً بخشی از Filesystem نیست.
        </td>
      </tr>
      <tr>
        <td>/root</td>
        <td>دایرکتوری home برای یوزر root است.</td>
      </tr>
      <tr>
        <td>/sbin</td>
        <td>
          این دایرکتوری شامل باینری‌های سیستمی است؛ یعنی برنامه‌هایی که کارهای
          حیاتی مربوط به سیستم را انجام می‌دهند و فقط توسط یوزر ادمین قابل اجرا
          هستند.
        </td>
      </tr>
      <tr>
        <td>/tmp</td>
        <td>
          این دایرکتوری برای ذخیره‌ی فایل‌های موقت تولید شده توسط برنامه‌ها
          طراحی شده است. معمولاً تنظیمات سیستم‌ها به‌گونه‌ای باشد که این
          دایرکتوری با هر ری‌استارت، خالی شود.
        </td>
      </tr>
      <tr>
        <td>/usr</td>
        <td>
          بزرگترین دایرکتوری در یک سیستم لینوکسی است که شامل همه‌ی برنامه‌ها و
          فایل‌های مورد استفاده توسط کاربران عادی است.
        </td>
      </tr>
      <tr>
        <td>/usr/bin</td>
        <td>
          شامل برنامه‌های اجرایی نصب‌شده توسط توزیع لینوکسی است. معمولاً این
          دایرکتوری شامل هزاران فایل است.
        </td>
      </tr>
      <tr>
        <td>/usr/lib</td>
        <td>
          شامل کتابخانه‌های اشتراکی است که توسط برنامه‌های موجود در
          /usr/bin استفاده می‌شوند.
        </td>
      </tr>
      <tr>
        <td>/usr/local</td>
        <td>
          برنامه‌هایی که برای استفاده‌ی کل سیستم در نظر گرفته شده‌اند، در این
          دایرکتوری قرار می‌گیرند. این دایرکتوری در ابتدا خالی است تا زمانی که
          مدیر سیستم چیزی به آن اضافه کند.
        </td>
      </tr>
      <tr>
        <td>/usr/sbin</td>
        <td>شامل برنامه‌های سیستمی در سطح ادمین است.</td>
      </tr>
      <tr>
        <td>/usr/share</td>
        <td>
          حاوی تمام داده‌های مشترک استفاده‌شده توسط برنامه‌های موجود در
          /usr/bin است. مثلاً فایل‌های کانفیگ، آیکون‌ها و فایل‌های
          صوتی در این دایرکتوری هستند.
        </td>
      </tr>
      <tr>
        <td>/usr/share/doc</td>
        <td>
          اکثر برنامه‌های نصبی شامل نوعی مستندات هستند که آنها را می‌توانیم در
          این دایرکتوری پیدا کنیم.
        </td>
      </tr>
      <tr>
        <td>/var</td>
        <td>
          داده‌هایی که مستعد تغییر هستند (مثل دیتابیس‌ها، فایل‌های spool، ایمیل
          کاربر و غیره) در این دایرکتوری نگهداری می‌شوند.
        </td>
      </tr>
      <tr>
        <td>/var/log</td>
        <td>
          این دایرکتوری حاوی فایل‌های log است که سوابق فعالیت‌های سیستم را نشان
          می‌دهند. دسترسی به برخی از این گزارشات به مجوز ادمین نیاز دارد.
        </td>
      </tr>
    </tbody>
  </table>
</section>
<section>
  <h2>آشنایی با لینک‌های Soft و Hard</h2>
  <p>خروجی زیر را برای کامند <bdi>ls</bdi> -l در نظر بگیرید:</p>
  <pre dir="ltr" data-cm-lang="bash">
lrwxrwxrwx 1 root root 11 2024-06-11 07:34 foo -> foo-2.6
</pre
  >
  <p>
    یادآوری می‌کنم که اولین حرف از رشته‌ی ۱۰ کاراکتری ابتدای خروجی کامند
    ls -l نشان‌دهنده‌ی نوع فایل است که در مورد فایل‌های معمولی کاراکتر
    dash و در مورد دایرکتوری‌ها d است. در مثال بالا، این حرف l است که از عبارت
    link گرفته شده و به این معناست که فایل مورد نظر یک لینک به فایلی دیگر است.
    نام این لینک foo است که به فایلی با نام foo-2.6 اشاره می‌کند. نحوه‌ی ایجاد
    لینک‌ها را بعداً خواهیم دید اما الان می‌خواهیم بدانیم استفاده از لینک‌ها چه
    لطفی دارد.
  </p>
  <p>
    فرض کنید فایلی داریم با نام foo که در چندین برنامه از آن استفاده می‌شود. از
    طرفی این فایل در طول زمان تغییر می‌کند و یک نسخه‌ی جدید از آن ارائه می‌شود.
    وقتی ورژن این فایل مثلاً از 2.6 به 2.7 تغییر می‌کند، باید این تغییر را روی
    همه‌ی برنامه‌هایی که از این فایل استفاده می‌کنند، اعمال کنیم که کاری است پر
    زحمت و مستعد خطا. اینجاست که لینک‌های Soft به کمک ما می‌آیند.
  </p>
  <p>
    ما لینکی به نام foo به ورژن فعلی ایجاد می‌کنیم و در برنامه‌ها به جای فایل از
    این لینک استفاده می‌کنیم. حالا هر بار که ورژن فایل تغییر کند، کافیست فقط
    لینک موجود را حذف کنیم و یک لینک به فایل جدید ایجاد کنیم. با این کار، اولاً
    فقط نیاز به انجام یک تغییر وجود دارد و ثانیاً می‌توانیم نسخه‌های قبلی را هم
    نگه داریم تا اگر به هر دلیلی (مثل وجود یک باگ در نسخه‌ی جدید) خواستیم به
    نسخه‌ی قبلی برگردیم، این کار به سادگی ممکن باشد.
  </p>
  <p>
    نوع دیگری از لینک‌ها هم وجود دارند که با نام لینک Hard شناخته می‌شوند. در
    مورد این لینک‌ها و تفاوتی که با لینک‌های Soft دارند و همینطور در مورد نحوه‌ی
    ایجاد لینک‌ها در درس بعد صحبت خواهیم کرد.
  </p>
</section>
