<section data-intro class="bg-slate-900/20">
  <h2>مقدمه</h2>
  <p>
    یک از اولین چیزهایی که باید در محیط لینوکس با آن آشنا شویم، معماری
    Filesystem است. در دنیای لینوکس، واژه‌ی Filesystem به دو معنی به کار می‌رود.
    از یک منظر، Filesystem به ساختار درختی دایرکتوری‌ها گفته می‌شود که یک
    دایرکتوری با نام root در ریشه‌ی این درخت قرار دارد و از یک منظر دیگر،
    Filesystem به فرمت واقعی فایل‌ها گفته می‌شود که به بحث دیسک‌ها و دستگاه‌های
    ذخیره‌سازی (storage devices) مربوط می‌شود. در این درس، ما Filesystem را از
    منظر اول بررسی می‌کنیم تا با ساختار فایل‌ها و دایرکتوری‌های لینوکس آشنا
    شویم. در این راستا با سه کامند پر کاربرد pwd، cd و ls آشنا می‌شویم که اولی
    برای نمایش دایرکتوری جاری، دومی برای جابجا شدن بین دایرکتوری‌های Filesystem
    و سومی برای لیست کردن فایل‌های موجود در یک دایرکتوری کاربرد دارند.
  </p>
</section>
<section>
  <h2>درخت File system</h2>
  <p>
    همانند ویندوز، یک سیستم عامل Unix-like مانند لینوکس نیز از یک ساختار
    دایرکتوری سلسله‌مراتبی برای سازماندهی فایل‌های خود استفاده می‌کند. این یعنی
    اینکه فایل‌ها در قالب یک ساختار درخت‌مانند از دایرکتوری‌ها (که در برخی سیستم
    عامل‌ها فولدر گفته می‌شوند) سازماندهی می‌شوند. هر دایرکتوری می‌تواند شامل
    فایل‌ها و دایرکتوری‌های دیگر باشد. ریشه‌ی این ساختار درختی یک دایرکتوری با
    نام root است.
  </p>
  <p>
    پس درخت Filesystem در لینوکس با root شروع می‌شود که شامل چند فایل و چند
    دایرکتوری دیگر است و هر یک از این دایرکتوری‌ها شامل فایل‌ها و دایرکتوری‌های
    دیگر هستند و الی آخر. به این ترتیب، یک الگوی درختی شکل می‌گیرد که معماری
    Filesystem در لینوکس را نشان می‌دهد.
  </p>
  <p>
    ساختار Filesystem در ویندوز متفاوت است. در ویندوز هر درایو یا به‌ طور کلی هر
    دستگاه ذخیره‌سازی (storage device) دارای یک Filesystem مختص خود است و درخت
    خودش را دارد. در لینوکس وقتی یک دیوایس جدید اضافه کنیم، یک Filesystem مجزا
    ایجاد نمی‌شود، بلکه این دیوایس به جایی از ساختار درختی موجود ضمیمه یا به
    بیان دقیق‌تر mount می‌شود.
  </p>
</section>
<section>
  <h2>دایرکتوری جاری</h2>
  <p>
    همه‌ی ما با File Manager گرافیکی که درخت Filesystem را نمایش می‌دهد، آشنا
    هستیم.
  </p>
  <figure>
    <img src="" alt="Filesystem GUI" data-caption="filesystem-gui.png" />
    <figcaption>GUI File Manager</figcaption>
  </figure>
  <p>
    اما در خط فرمان خبری از تصاویر نیست و بنابراین، برای پیمایش در Filesystem
    باید طور دیگری فکر کنیم. تصور کنید که Filesystem مانند یک درخت وارونه است که
    ما جایی در وسط آن ایستاده‌ایم. در هر لحظه ما در یک دایرکتوری واحد قرار داریم
    و می‌توانیم محتویات این دایرکتوری و مسیر دسترسی به دایرکتوری‌های بالایی و
    پایینی را ببینیم. دایرکتوری که در آن قرار داریم، دایرکتوری کاری جاری نام
    دارد و برای نمایش آن می‌توانیم از کامند pwd استفاده کنیم که مخففی است برای
    Print Working Directory.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ pwd
/home/me</pre
  >
  <p>
    وقتی یک ترمینال باز می‌کنیم، در حالت پیش‌فرض در دایرکتوری home مربوط به یوزر
    جاری قرار داریم. هر یوزر دارای یک دایرکتوری home است و این دایرکتوری تنها
    جایی است که آن یوزر می‌تواند اعمال نوشتن (write operations) را انجام دهد.
    دایرکتوری home مربوط به یک یوزر با نام me دایرکتوری /home/me است. یعنی در
    دایرکتوری root که با / نمایش داده می‌شود، یک دایرکتوری با نام home وجود دارد
    و در این دایرکتوری به‌ازای هر یوزر یک دایرکتوری با نام یوزر وجود دارد.
  </p>
</section>
<section>
  <h2>مشاهده محتوای یک دایرکتوری</h2>
  <p>
    برای مشاهده ی لیست فایل‌ها و دایرکتوری‌های موجود در دایرکتوری جاری از دستور
    ls استفاده می‌کنیم.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
$ ls
Desktop Documents Music Pictures Public Templates Videos</pre
  >
  <p>
    البته دستور ls می‌تواند مختویات هر دایرکتوری در هر جای Filesystem را نمایش
    دهد (نه فقط دایرکتوری جاری) و قادر است کارهای بسیار بیشتری را انجام دهد. در
    فصل سوم با قابلیت‌های ls بیشتر آشنا می‌شویم.
  </p>
</section>
<section>
  <h2>تغییر دایرکتوری جاری</h2>
  <p>
    برای تغییر دایرکتوری جاری و انتقال به یک دایرکتوری دیگر از دستور cd استفاده
    می‌کنیم که مخففی است برای Change Directory. به دستور cd می‌توانیم یک آرگومان
    پاس کنیم که مشخص‌کننده‌ی مسیر دایرکتوری مقصد است. مسیر دایرکتوری مقصد را
    می‌توانیم به یکی از دو روش مطلق (absolute) یا نسبی (relative) تعیین کنیم.
  </p>
  <h3>مسیرهای مطلق</h3>
  <p>
    یک مسیر مطلق با دایرکتوری root شروع شده و درخت Filesystem را طی می‌کند تا به
    دایرکتوری یا فایل مقصد برسد. برای مثال، در Filesystem یک دایرکتوری وجود دارد
    که شامل اغلب برنامه‌های سیستمی است. مسیر مطلق این دایرکتوری به صورت /usr/bin
    است که به این معناست که درون root که با / نمایش داده می‌شود یک دایرکتوری با
    نام usr و درون usr یک دایرکتوری با نام bin قرار دارد.
  </p>
  <pre dir="ltr" data-cm-lang="bash">
[me@linuxbox ~]$ cd /usr/bin
[me@linuxbox bin]$ pwd
/usr/bin</pre
  >
  <p>
    دقت کنید که با تغییر دایرکتوری جاری، Shell Prompt نیز تغییر می‌کند. در واقع،
    shell Prompt طوری تنظیم شده که همیشه نام دایرکتوری جاری را نمایش دهد.
  </p>
  <h3>مسیرهای نسبی</h3>
  <p>
    گفتیم که یک مسیر مطلق همواره از root شروع شده و به سمت دایرکتوری مقصد حرکت
    می‌کند. یک مسیر نسبی از دایرکتوری جاری شروع می‌شود. در یک مسیر نسبی، کاراکتر
    . به دایرکتوری جاری و کاراکتر .. به دایرکتوری والد اشاره می‌کنند.
  </p>
  <p>
    فرض کنید در دایرکتوری /usr/bin قرار داریم و می‌خواهیم به دایرکتوری والد
    دایرکتوری جاری یعنی /usr برویم. این کار را به دو روش می‌توانیم انجام دهیم.
    یکی با استفاده از یک پارامتر مطلق:
  </p>
  <pre dir="ltr" data-cm-lang="">
[me@linuxbox bin]$ cd /usr
[me@linuxbox usr]$ pwd
/usr</pre
  >
  <p>و دیگری با استفاده از یک پارامتر نسبی:</p>
  <pre dir="ltr" data-cm-lang="">
[me@linuxbox bin]$ cd ..
[me@linuxbox usr]$ pwd
/usr</pre
  >
  <p>
    گفتیم که کاراکتر . نشان‌دهنده‌ی دایرکتوری جاری است اما تقریباً در همه‌ی
    موارد می‌توانیم از آوردن آن صرف‌نظر کنیم. مثلاً مسیر bin با مسیر ./bin هر دو
    به یک معنا هستند.
  </p>
  <div data-callout="tip">
    <strong>نکات مهم در مورد نام فایل‌ها</strong>
    <p>
      نامگذاری فایل‌ها در سیستم‌های لینوکسی از خیلی جهات مشابه سایر سیستم‌ها
      مانند ویندوز است اما تفاوت‌هایی هم وجود دارد که باید بدانیم:
    </p>
    <ul class="list-disc pr-6">
      <li>
        فایل‌هایی که نامشان با یک کاراکتر . شروع می‌شود، مخفی هستند. این
        مخفی‌بودن به این معناست که در خروجی دستور ls نمایش داده نمی‌شوند، مگر
        اینکه از این دستور به فرم ls -a استفاده کنیم. وقتی یک اکانت کاربری ساخته
        می‌شود، تعدادی فایل مخفی در دایرکتوری home قرار می‌گیرند که شامل
        کانفیگ‌های لازم برای آن اکانت هستند. در فصل ۱۱ نگاهی به برخی از این
        فایل‌ها خواهیم داشت تا ببینیم چطور می‌توانیم محیط خود را سفارشی‌سازی
        کنیم. علاوه بر این، برخی اپلیکیشن‌ها هم فایل‌های تنظیماتی و کانفیگ خود
        را در دایرکتوری home به صورت مخفی ذخیره می‌کنند.
      </li>
      <li>
        نام فایل‌ها و همینطور کامندها در لینوکس مانند یویکس، حساس‌به‌حروف است.
        عبارات file1 و File1 می‌توانند به دو فایل متفاوت در یک دایرکتوری اختصاص
        داده شوند.
      </li>
      <li>
        با وجودی که لینوکس از نام‌های طولانی که دارای کاراکترهای مختلف و از جمله
        space هستند، برای فایل‌ها پشتیبانی می‌کند اما بهتر است علاوه بر حروف و
        اعداد تنها از کاراکترهای . و – و ـ در نام فایل‌های خود استفاده کنیم.
        به‌ویژه اینکه به هیچ وجه از space در نام فایل‌های خود استفاده نکنید و در
        عوض، برای جدا کردن عبارات یک نام از ـ استفاده کنید.
      </li>
      <li>
        در لینوکس مفهوم پسوند فایل (file extension) مانند آنچه در سیستم‌های دیگر
        دیده‌ایم، وجود ندارد. به طور کلی، در سیستم‌های Unix-like مانند لینوکس،
        از پسوند فایل برای مشخص کردن محتوا یا هدف آن فایل استفاده نمی‌شود؛ البته
        برخی اپ‌ها این کار را انجام می‌دهند.
      </li>
    </ul>
    <p>در پایان به چند روش برای تغییر سریع‌تر دایرکتوری جاری اشاره می‌کنیم:</p>
    <ul class="list-disc pr-6">
      <li>
        با استفاده از دستور cd بدون هیچ آرگومانی، به دایرکتوری home منتقل
        می‌شویم.
      </li>
      <li>دستور cd – ما را به دایرکتوری قبلی که در آن بودیم، منتقل می‌کند.</li>
      <li>
        دستور cd ~user_name ما را به دایرکتوری home یک یوزر مشخص می‌برد. برای
        مثال، دستور cd ~dabi ما را به دایرکتوری home یوزری با نام dabi می‌برد.
      </li>
    </ul>
  </div>
</section>
